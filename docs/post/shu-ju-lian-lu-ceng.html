<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    <script src='https://blog.meekdai.com/Gmeek/plugins/GmeekVercount.js'></script>
    <link rel="icon" href="https://telegraph-image-6b4.pages.dev/file/3a89e862ad5a60a260608.jpg"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="# 数据链路层

## 数据链路层的功能

### 概念

1. 数据链路层的主要任务是实现帧在一段链路上或一个网络中进行传输
2. 数据链路层使用的信道：
   - 点对点信道：使用一对一通信方式
   - 广播信道：信道上连接的主机很多，使用一对多的广播通信方式
3. 链路/物理链路：从一个节点到相邻节点的一段物理线路
4. 数据链路/逻辑链路：当在一条链路上传送数据时，除了需要链路本身，还需要一些必要的通信协议来控制这些数据的传输，把实现这些协议的硬件和软件加到链路上，就构成了数据链路
5. 帧：数据链路层对等实体之间进行逻辑通信的协议数据单元

### 为网络层提供服务

1. 无确认的无连接服务：

   - 源主机发送帧时不需要先建立链路连接，目的主机收到帧时不需要发回确认
   - 适用于误码率较低的信道

2. 有确认的无连接服务：

   - 源主机发送帧时不需要先建立链路连接，目的主机收到帧时需要发回确认
   - 适用于误码率较高的信道

3. 有确认的面向连接服务：

   - 帧传输过程分为三个阶段，目的主机对收到的每一个帧都要返回确认

   ```mermaid
   graph LR
   	A(建立链路)-->B(传输帧)-->C(释放链路)
   ```

   - 适用于可靠性要求较高的场合

### 链路管理

1. 链路管理：数据链路层连接的建立、维持和释放过程
2. 主要用于面向连接服务

### 组装成帧与透明传输

1. 封装成帧：指在一段数据的前后分别添加首部和尾部，构成帧，帧是数据链路层的数据传送单元
2. 帧长：帧的数据部分长度加上首部和尾部的长度
3. 首部和尾部中含有很多控制信息，一个作用就是确定真的界限，即帧定界
4. 每个链路层协议都规定了帧的数据部分的长度上限，即最大传送单元
5. 透明传输：不论传送什么数据，都能无差错地在数据链路上传输

### 流量控制

1. 限制发送方地发送速率，使之不超过接收方的接受能力
2. 在OSI体系结构中，数据链路层具有流量控制的功能，控制的是相邻节点之间的数据链路上地流量
3. 在TCP/IP体系结构中，流量控制功能被移到传输层，控制的是源端到目的端之间的流量

### 差错控制

1. 位错：帧中某些位出现差错，通常采用循环冗余检查来发现位错
2. 帧错：帧丢失、帧重复或帧失序等错误，都属于传输差错

### 错题

1. 数据链路层协议的功能不包括(  )

   A. 定义数据格式

   B. 提供节点之间的可靠传输

   C. 控制对物理传输介质的访问

   D. 为终端节点隐蔽物理传输的细节

2. 为了避免传输过程中帧的丢失，数据链路层采用的方法是(  )

   A. 帧编号机制

   B. 循环冗余验证码

   C. 海明码

   D. 计时器超时重发

## 组帧

### 字符计数法

1. 在帧首部使用一个计数字段来记录该帧所含的字节数(包含计数字段自身所占用的一个字节)

   ![flower](https://telegraph-image-6b4.pages.dev/file/648a9ee0be37e2639174f.png)

2. 缺点：若计数字段出错，则所有帧都将出错，收发双方失去同步

### 字节填充法

1. 使用特定字节来定界一帧的开始与结束
2. 控制字符SOH放在帧的最前面，表示帧的开始，控制字符EOT表示帧的结束
3. 为了使信息位中出现的特殊字符不被误判为帧的首位定界符，可在特殊字符之前填充一个转义字符ESC加以区分

![flower](https://telegraph-image-6b4.pages.dev/file/cd7dc38ac0e1c7a14774d.png)

### 零比特填充法

1. 允许数据帧包含任意个数的比特，它使用一个特定的比特串0111110来表示一个帧的开始和结束
2. 为了不使数据字段中出现的比特流01111110被误判为帧的守卫表示，发送方先扫描整个数据字段，每遇到5个连续的1便在后面插入一个0；接收方每收到5个连续的1，就自动删除后面紧跟的0

### 违规编码法

1. 曼彻斯特编码方法将数据比特1编码成“高-低”电平对，将数据比特0编码成“低-高”电平对，而“高高”电平对和“低低”电平对在数据比特中是违规的，因此可采用这些违规编码来界定帧的起始和终止
2. 只适用于采用冗余编码的特殊编码环境

## 差错控制

利用编码技术进行差错控制，主要有两类：

- 自动重传请求ARQ：当接收方检测到差错时，就设法通知发送方重发，直到收到正常的数据
- 前向纠错FEC：接收方不但能发现差错，还能确定错误的位置并加以纠正

### 检错编码

1. 奇偶校验码

   - 奇校验码：附加一个检验位后，码长为n的码字中1的个数为奇数
   - 偶校验码：附加一个校验位后，码长为n的码字中1的个数为偶数

   ```mermaid
   graph LR
   	A(1001101)
   	A-->|奇校验码|B(10011011)
   	A-->|偶校验码|C(10011010)
   ```

2. 循环冗余码

   - CRC检错的基本思想
     1. 收发双方约定生成多项式G(x)
     2. 发送方基于待发送数据和G(x)，计算出冗余码，将冗余码附加到数据后面一起发送
     3. 接收方收到数据和冗余码后，通过G(x)来计算收到的数据和冗余码是否产生差错
   - CRC检错的步骤
     1. 假设一个带传送m位的数据，CRC运算产生一个r位的冗余码，称为帧检验序列FCS
     2. 附加到m位数据后，形成长度为m+r的帧用于发送
     3. 接收方用相同的多项式去除收到的帧，若无余数，则认为无差错

### 纠错编码

以数据1100为例

1. 确定海明码的位数

   - 设n为有效信息的位数，k为检验位的位数，则信息位n和检验位k应满足n+k≤2^k^-1
   - 4+k≤2^k^-1$\Rightarrow$k≥3

2. 确定检验位的分布

   - 规定第i个检验位在海明位号为2^i-1^的位置上，其余各位为信息位
   - 三个检验位的位号分别为2^0^、2^1^、2^2^$\Rightarrow$110x~4~0x~2~x~1~

3. 分组以形成检验关系

   - 每个数据位用多个检验位进行检验，但要满足条件：被检验数据位的海明位号等于检验该数据位的各检验位海明位号之和

   - | 111  | 110  | 101  | 100(1**) | 011  | 010(\*1\*) | 001(**1) |
     | :--: | :--: | :--: | :------: | :--: | :--------: | :------: |
     |  1   |  1   |  0   |   x~4~   |  0   |    x~2~    |   x~1~   |

     根据检验位位号对应的通配符：

     - x~4~负责检验111、110、101、100号
     - x~2~负责检验111、110、011、010号
     - x~1~负责检验111、101、011、001号

4. 检验位取值

   - 第i个检验位的值应为第i组所有位求异或
   - 若采用偶校验：x~4~=1$\oplus$1$\oplus$0=0;x~2~=1$\oplus$1$\oplus$0=0;x~1~=1$\oplus$0$\oplus$0=1，因此最终要发送的数据为1100001

5. 海明码的检验原理

   - 每个检验组分别利用检验位和参与形成该检验位的信息位进行奇偶检验检查，将结果转置，对应的编号即为错误位的位号

   - 假设接收方收到的数据为：1110001，则

     - x~4~：0$\oplus$1$\oplus$1$\oplus$1=1
     - x~2~：0$\oplus$0$\oplus$1$\oplus$1=0
     - x~1~：1$\oplus$0$\oplus$1$\oplus$1=1

     则发生错误的位号为x~4~x~2~x~1~：101=5

## 流量控制与可靠传输机制

### 流量控制与滑动窗口机制

1. 流量控制：由接收方控制发送方的发送速率，使接收方有足够的缓存空间来接受每个帧
2. 常见的流量控制方法有两种：
   - 停止-等待协议
   - 滑动窗口协议
3. 数据链路层和传输层都有流量控制功能，且都用到了滑动窗口协议，区别是
   - 数据链路层控制的是相邻节点之间的流量，而传输层控制的是端到端的流量
   - 数据链路层的控制手段是接收方收不下就不返回确认。">
<meta property="og:title" content="数据链路层">
<meta property="og:description" content="# 数据链路层

## 数据链路层的功能

### 概念

1. 数据链路层的主要任务是实现帧在一段链路上或一个网络中进行传输
2. 数据链路层使用的信道：
   - 点对点信道：使用一对一通信方式
   - 广播信道：信道上连接的主机很多，使用一对多的广播通信方式
3. 链路/物理链路：从一个节点到相邻节点的一段物理线路
4. 数据链路/逻辑链路：当在一条链路上传送数据时，除了需要链路本身，还需要一些必要的通信协议来控制这些数据的传输，把实现这些协议的硬件和软件加到链路上，就构成了数据链路
5. 帧：数据链路层对等实体之间进行逻辑通信的协议数据单元

### 为网络层提供服务

1. 无确认的无连接服务：

   - 源主机发送帧时不需要先建立链路连接，目的主机收到帧时不需要发回确认
   - 适用于误码率较低的信道

2. 有确认的无连接服务：

   - 源主机发送帧时不需要先建立链路连接，目的主机收到帧时需要发回确认
   - 适用于误码率较高的信道

3. 有确认的面向连接服务：

   - 帧传输过程分为三个阶段，目的主机对收到的每一个帧都要返回确认

   ```mermaid
   graph LR
   	A(建立链路)-->B(传输帧)-->C(释放链路)
   ```

   - 适用于可靠性要求较高的场合

### 链路管理

1. 链路管理：数据链路层连接的建立、维持和释放过程
2. 主要用于面向连接服务

### 组装成帧与透明传输

1. 封装成帧：指在一段数据的前后分别添加首部和尾部，构成帧，帧是数据链路层的数据传送单元
2. 帧长：帧的数据部分长度加上首部和尾部的长度
3. 首部和尾部中含有很多控制信息，一个作用就是确定真的界限，即帧定界
4. 每个链路层协议都规定了帧的数据部分的长度上限，即最大传送单元
5. 透明传输：不论传送什么数据，都能无差错地在数据链路上传输

### 流量控制

1. 限制发送方地发送速率，使之不超过接收方的接受能力
2. 在OSI体系结构中，数据链路层具有流量控制的功能，控制的是相邻节点之间的数据链路上地流量
3. 在TCP/IP体系结构中，流量控制功能被移到传输层，控制的是源端到目的端之间的流量

### 差错控制

1. 位错：帧中某些位出现差错，通常采用循环冗余检查来发现位错
2. 帧错：帧丢失、帧重复或帧失序等错误，都属于传输差错

### 错题

1. 数据链路层协议的功能不包括(  )

   A. 定义数据格式

   B. 提供节点之间的可靠传输

   C. 控制对物理传输介质的访问

   D. 为终端节点隐蔽物理传输的细节

2. 为了避免传输过程中帧的丢失，数据链路层采用的方法是(  )

   A. 帧编号机制

   B. 循环冗余验证码

   C. 海明码

   D. 计时器超时重发

## 组帧

### 字符计数法

1. 在帧首部使用一个计数字段来记录该帧所含的字节数(包含计数字段自身所占用的一个字节)

   ![flower](https://telegraph-image-6b4.pages.dev/file/648a9ee0be37e2639174f.png)

2. 缺点：若计数字段出错，则所有帧都将出错，收发双方失去同步

### 字节填充法

1. 使用特定字节来定界一帧的开始与结束
2. 控制字符SOH放在帧的最前面，表示帧的开始，控制字符EOT表示帧的结束
3. 为了使信息位中出现的特殊字符不被误判为帧的首位定界符，可在特殊字符之前填充一个转义字符ESC加以区分

![flower](https://telegraph-image-6b4.pages.dev/file/cd7dc38ac0e1c7a14774d.png)

### 零比特填充法

1. 允许数据帧包含任意个数的比特，它使用一个特定的比特串0111110来表示一个帧的开始和结束
2. 为了不使数据字段中出现的比特流01111110被误判为帧的守卫表示，发送方先扫描整个数据字段，每遇到5个连续的1便在后面插入一个0；接收方每收到5个连续的1，就自动删除后面紧跟的0

### 违规编码法

1. 曼彻斯特编码方法将数据比特1编码成“高-低”电平对，将数据比特0编码成“低-高”电平对，而“高高”电平对和“低低”电平对在数据比特中是违规的，因此可采用这些违规编码来界定帧的起始和终止
2. 只适用于采用冗余编码的特殊编码环境

## 差错控制

利用编码技术进行差错控制，主要有两类：

- 自动重传请求ARQ：当接收方检测到差错时，就设法通知发送方重发，直到收到正常的数据
- 前向纠错FEC：接收方不但能发现差错，还能确定错误的位置并加以纠正

### 检错编码

1. 奇偶校验码

   - 奇校验码：附加一个检验位后，码长为n的码字中1的个数为奇数
   - 偶校验码：附加一个校验位后，码长为n的码字中1的个数为偶数

   ```mermaid
   graph LR
   	A(1001101)
   	A-->|奇校验码|B(10011011)
   	A-->|偶校验码|C(10011010)
   ```

2. 循环冗余码

   - CRC检错的基本思想
     1. 收发双方约定生成多项式G(x)
     2. 发送方基于待发送数据和G(x)，计算出冗余码，将冗余码附加到数据后面一起发送
     3. 接收方收到数据和冗余码后，通过G(x)来计算收到的数据和冗余码是否产生差错
   - CRC检错的步骤
     1. 假设一个带传送m位的数据，CRC运算产生一个r位的冗余码，称为帧检验序列FCS
     2. 附加到m位数据后，形成长度为m+r的帧用于发送
     3. 接收方用相同的多项式去除收到的帧，若无余数，则认为无差错

### 纠错编码

以数据1100为例

1. 确定海明码的位数

   - 设n为有效信息的位数，k为检验位的位数，则信息位n和检验位k应满足n+k≤2^k^-1
   - 4+k≤2^k^-1$\Rightarrow$k≥3

2. 确定检验位的分布

   - 规定第i个检验位在海明位号为2^i-1^的位置上，其余各位为信息位
   - 三个检验位的位号分别为2^0^、2^1^、2^2^$\Rightarrow$110x~4~0x~2~x~1~

3. 分组以形成检验关系

   - 每个数据位用多个检验位进行检验，但要满足条件：被检验数据位的海明位号等于检验该数据位的各检验位海明位号之和

   - | 111  | 110  | 101  | 100(1**) | 011  | 010(\*1\*) | 001(**1) |
     | :--: | :--: | :--: | :------: | :--: | :--------: | :------: |
     |  1   |  1   |  0   |   x~4~   |  0   |    x~2~    |   x~1~   |

     根据检验位位号对应的通配符：

     - x~4~负责检验111、110、101、100号
     - x~2~负责检验111、110、011、010号
     - x~1~负责检验111、101、011、001号

4. 检验位取值

   - 第i个检验位的值应为第i组所有位求异或
   - 若采用偶校验：x~4~=1$\oplus$1$\oplus$0=0;x~2~=1$\oplus$1$\oplus$0=0;x~1~=1$\oplus$0$\oplus$0=1，因此最终要发送的数据为1100001

5. 海明码的检验原理

   - 每个检验组分别利用检验位和参与形成该检验位的信息位进行奇偶检验检查，将结果转置，对应的编号即为错误位的位号

   - 假设接收方收到的数据为：1110001，则

     - x~4~：0$\oplus$1$\oplus$1$\oplus$1=1
     - x~2~：0$\oplus$0$\oplus$1$\oplus$1=0
     - x~1~：1$\oplus$0$\oplus$1$\oplus$1=1

     则发生错误的位号为x~4~x~2~x~1~：101=5

## 流量控制与可靠传输机制

### 流量控制与滑动窗口机制

1. 流量控制：由接收方控制发送方的发送速率，使接收方有足够的缓存空间来接受每个帧
2. 常见的流量控制方法有两种：
   - 停止-等待协议
   - 滑动窗口协议
3. 数据链路层和传输层都有流量控制功能，且都用到了滑动窗口协议，区别是
   - 数据链路层控制的是相邻节点之间的流量，而传输层控制的是端到端的流量
   - 数据链路层的控制手段是接收方收不下就不返回确认。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://wlkla.github.io/onebuaaer.github.io/post/shu-ju-lian-lu-ceng.html">
<meta property="og:image" content="https://telegraph-image-6b4.pages.dev/file/3a89e862ad5a60a260608.jpg">
<title>数据链路层</title>
<link href="//unpkg.com/@wooorm/starry-night@2.1.1/style/both.css" rel="stylesheet" />


</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
.copy-feedback {
    display: none;
    position: absolute;
    top: 10px;
    right: 50px;
    color: var(--color-fg-on-emphasis);
    background-color: var(--color-fg-muted);
    border-radius: 3px;
    padding: 5px 8px;
    font-size: 12px;
}
</style>




<body>
    <div id="header">
<h1 class="postTitle">数据链路层</h1>
<div class="title-right">
    <a href="https://wlkla.github.io/onebuaaer.github.io" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/wlkla/onebuaaer.github.io/issues/9" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><h1>数据链路层</h1>
<h2>数据链路层的功能</h2>
<h3>概念</h3>
<ol>
<li>数据链路层的主要任务是实现帧在一段链路上或一个网络中进行传输</li>
<li>数据链路层使用的信道：
<ul>
<li>点对点信道：使用一对一通信方式</li>
<li>广播信道：信道上连接的主机很多，使用一对多的广播通信方式</li>
</ul>
</li>
<li>链路/物理链路：从一个节点到相邻节点的一段物理线路</li>
<li>数据链路/逻辑链路：当在一条链路上传送数据时，除了需要链路本身，还需要一些必要的通信协议来控制这些数据的传输，把实现这些协议的硬件和软件加到链路上，就构成了数据链路</li>
<li>帧：数据链路层对等实体之间进行逻辑通信的协议数据单元</li>
</ol>
<h3>为网络层提供服务</h3>
<ol>
<li>
<p>无确认的无连接服务：</p>
<ul>
<li>源主机发送帧时不需要先建立链路连接，目的主机收到帧时不需要发回确认</li>
<li>适用于误码率较低的信道</li>
</ul>
</li>
<li>
<p>有确认的无连接服务：</p>
<ul>
<li>源主机发送帧时不需要先建立链路连接，目的主机收到帧时需要发回确认</li>
<li>适用于误码率较高的信道</li>
</ul>
</li>
<li>
<p>有确认的面向连接服务：</p>
<ul>
<li>帧传输过程分为三个阶段，目的主机对收到的每一个帧都要返回确认</li>
</ul>
<div class="highlight highlight-source-mermaid"><pre class="notranslate"><span class="pl-k">graph</span> <span class="pl-c1">LR</span>
	<span class="pl-ent">A</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>建立链路<span class="pl-pds"><span class="pl-sg">)</span></span></span><span class="pl-k">--&gt;</span><span class="pl-ent">B</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>传输帧<span class="pl-pds"><span class="pl-sg">)</span></span></span><span class="pl-k">--&gt;</span><span class="pl-ent">C</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>释放链路<span class="pl-pds"><span class="pl-sg">)</span></span></span></pre></div>
<ul>
<li>适用于可靠性要求较高的场合</li>
</ul>
</li>
</ol>
<h3>链路管理</h3>
<ol>
<li>链路管理：数据链路层连接的建立、维持和释放过程</li>
<li>主要用于面向连接服务</li>
</ol>
<h3>组装成帧与透明传输</h3>
<ol>
<li>封装成帧：指在一段数据的前后分别添加首部和尾部，构成帧，帧是数据链路层的数据传送单元</li>
<li>帧长：帧的数据部分长度加上首部和尾部的长度</li>
<li>首部和尾部中含有很多控制信息，一个作用就是确定真的界限，即帧定界</li>
<li>每个链路层协议都规定了帧的数据部分的长度上限，即最大传送单元</li>
<li>透明传输：不论传送什么数据，都能无差错地在数据链路上传输</li>
</ol>
<h3>流量控制</h3>
<ol>
<li>限制发送方地发送速率，使之不超过接收方的接受能力</li>
<li>在OSI体系结构中，数据链路层具有流量控制的功能，控制的是相邻节点之间的数据链路上地流量</li>
<li>在TCP/IP体系结构中，流量控制功能被移到传输层，控制的是源端到目的端之间的流量</li>
</ol>
<h3>差错控制</h3>
<ol>
<li>位错：帧中某些位出现差错，通常采用循环冗余检查来发现位错</li>
<li>帧错：帧丢失、帧重复或帧失序等错误，都属于传输差错</li>
</ol>
<h3>错题</h3>
<ol>
<li>
<p>数据链路层协议的功能不包括(  )</p>
<p>A. 定义数据格式</p>
<p>B. 提供节点之间的可靠传输</p>
<p>C. 控制对物理传输介质的访问</p>
<p>D. 为终端节点隐蔽物理传输的细节</p>
</li>
<li>
<p>为了避免传输过程中帧的丢失，数据链路层采用的方法是(  )</p>
<p>A. 帧编号机制</p>
<p>B. 循环冗余验证码</p>
<p>C. 海明码</p>
<p>D. 计时器超时重发</p>
</li>
</ol>
<h2>组帧</h2>
<h3>字符计数法</h3>
<ol>
<li>
<p>在帧首部使用一个计数字段来记录该帧所含的字节数(包含计数字段自身所占用的一个字节)</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/234430a17a1a887b4042561f21e3ffe21eba95ba9ddff90b293d52e803442068/68747470733a2f2f74656c6567726170682d696d6167652d3662342e70616765732e6465762f66696c652f3634386139656530626533376532363339313734662e706e67"><img src="https://camo.githubusercontent.com/234430a17a1a887b4042561f21e3ffe21eba95ba9ddff90b293d52e803442068/68747470733a2f2f74656c6567726170682d696d6167652d3662342e70616765732e6465762f66696c652f3634386139656530626533376532363339313734662e706e67" alt="flower" data-canonical-src="https://telegraph-image-6b4.pages.dev/file/648a9ee0be37e2639174f.png" style="max-width: 100%;"></a></p>
</li>
<li>
<p>缺点：若计数字段出错，则所有帧都将出错，收发双方失去同步</p>
</li>
</ol>
<h3>字节填充法</h3>
<ol>
<li>使用特定字节来定界一帧的开始与结束</li>
<li>控制字符SOH放在帧的最前面，表示帧的开始，控制字符EOT表示帧的结束</li>
<li>为了使信息位中出现的特殊字符不被误判为帧的首位定界符，可在特殊字符之前填充一个转义字符ESC加以区分</li>
</ol>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/96cd204645c39934a756a2add0e879ad675521c4cc7a96173e5a642e8e5e9d4c/68747470733a2f2f74656c6567726170682d696d6167652d3662342e70616765732e6465762f66696c652f6364376463333861633065316337613134373734642e706e67"><img src="https://camo.githubusercontent.com/96cd204645c39934a756a2add0e879ad675521c4cc7a96173e5a642e8e5e9d4c/68747470733a2f2f74656c6567726170682d696d6167652d3662342e70616765732e6465762f66696c652f6364376463333861633065316337613134373734642e706e67" alt="flower" data-canonical-src="https://telegraph-image-6b4.pages.dev/file/cd7dc38ac0e1c7a14774d.png" style="max-width: 100%;"></a></p>
<h3>零比特填充法</h3>
<ol>
<li>允许数据帧包含任意个数的比特，它使用一个特定的比特串0111110来表示一个帧的开始和结束</li>
<li>为了不使数据字段中出现的比特流01111110被误判为帧的守卫表示，发送方先扫描整个数据字段，每遇到5个连续的1便在后面插入一个0；接收方每收到5个连续的1，就自动删除后面紧跟的0</li>
</ol>
<h3>违规编码法</h3>
<ol>
<li>曼彻斯特编码方法将数据比特1编码成“高-低”电平对，将数据比特0编码成“低-高”电平对，而“高高”电平对和“低低”电平对在数据比特中是违规的，因此可采用这些违规编码来界定帧的起始和终止</li>
<li>只适用于采用冗余编码的特殊编码环境</li>
</ol>
<h2>差错控制</h2>
<p>利用编码技术进行差错控制，主要有两类：</p>
<ul>
<li>自动重传请求ARQ：当接收方检测到差错时，就设法通知发送方重发，直到收到正常的数据</li>
<li>前向纠错FEC：接收方不但能发现差错，还能确定错误的位置并加以纠正</li>
</ul>
<h3>检错编码</h3>
<ol>
<li>
<p>奇偶校验码</p>
<ul>
<li>奇校验码：附加一个检验位后，码长为n的码字中1的个数为奇数</li>
<li>偶校验码：附加一个校验位后，码长为n的码字中1的个数为偶数</li>
</ul>
<div class="highlight highlight-source-mermaid"><pre class="notranslate"><span class="pl-k">graph</span> <span class="pl-c1">LR</span>
	<span class="pl-ent">A</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>1001101<span class="pl-pds"><span class="pl-sg">)</span></span></span>
	<span class="pl-ent">A</span><span class="pl-k">--&gt;</span><span class="pl-k">|</span><span class="pl-s">奇校验码</span><span class="pl-k">|</span><span class="pl-ent">B</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>10011011<span class="pl-pds"><span class="pl-sg">)</span></span></span>
	<span class="pl-ent">A</span><span class="pl-k">--&gt;</span><span class="pl-k">|</span><span class="pl-s">偶校验码</span><span class="pl-k">|</span><span class="pl-ent">C</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>10011010<span class="pl-pds"><span class="pl-sg">)</span></span></span></pre></div>
</li>
<li>
<p>循环冗余码</p>
<ul>
<li>CRC检错的基本思想
<ol>
<li>收发双方约定生成多项式G(x)</li>
<li>发送方基于待发送数据和G(x)，计算出冗余码，将冗余码附加到数据后面一起发送</li>
<li>接收方收到数据和冗余码后，通过G(x)来计算收到的数据和冗余码是否产生差错</li>
</ol>
</li>
<li>CRC检错的步骤
<ol>
<li>假设一个带传送m位的数据，CRC运算产生一个r位的冗余码，称为帧检验序列FCS</li>
<li>附加到m位数据后，形成长度为m+r的帧用于发送</li>
<li>接收方用相同的多项式去除收到的帧，若无余数，则认为无差错</li>
</ol>
</li>
</ul>
</li>
</ol>
<h3>纠错编码</h3>
<p>以数据1100为例</p>
<ol>
<li>
<p>确定海明码的位数</p>
<ul>
<li>设n为有效信息的位数，k为检验位的位数，则信息位n和检验位k应满足n+k≤2^k^-1</li>
<li>4+k≤2^k^-1$\Rightarrow$k≥3</li>
</ul>
</li>
<li>
<p>确定检验位的分布</p>
<ul>
<li>规定第i个检验位在海明位号为2^i-1^的位置上，其余各位为信息位</li>
<li>三个检验位的位号分别为2^0^、2^1^、2^2^$\Rightarrow$110x<del>4</del>0x<del>2</del>x<del>1</del></li>
</ul>
</li>
<li>
<p>分组以形成检验关系</p>
<ul>
<li>
<p>每个数据位用多个检验位进行检验，但要满足条件：被检验数据位的海明位号等于检验该数据位的各检验位海明位号之和</p>
</li>
<li>
<markdown-accessiblity-table><table role="table">
<thead>
<tr>
<th align="center">111</th>
<th align="center">110</th>
<th align="center">101</th>
<th align="center">100(1**)</th>
<th align="center">011</th>
<th align="center">010(*1*)</th>
<th align="center">001(**1)</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">x<del>4</del></td>
<td align="center">0</td>
<td align="center">x<del>2</del></td>
<td align="center">x<del>1</del></td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p>根据检验位位号对应的通配符：</p>
<ul>
<li>x<del>4</del>负责检验111、110、101、100号</li>
<li>x<del>2</del>负责检验111、110、011、010号</li>
<li>x<del>1</del>负责检验111、101、011、001号</li>
</ul>
</li>
</ul>
</li>
<li>
<p>检验位取值</p>
<ul>
<li>第i个检验位的值应为第i组所有位求异或</li>
<li>若采用偶校验：x<del>4</del>=1$\oplus$1$\oplus$0=0;x<del>2</del>=1$\oplus$1$\oplus$0=0;x<del>1</del>=1$\oplus$0$\oplus$0=1，因此最终要发送的数据为1100001</li>
</ul>
</li>
<li>
<p>海明码的检验原理</p>
<ul>
<li>
<p>每个检验组分别利用检验位和参与形成该检验位的信息位进行奇偶检验检查，将结果转置，对应的编号即为错误位的位号</p>
</li>
<li>
<p>假设接收方收到的数据为：1110001，则</p>
<ul>
<li>x<del>4</del>：0$\oplus$1$\oplus$1$\oplus$1=1</li>
<li>x<del>2</del>：0$\oplus$0$\oplus$1$\oplus$1=0</li>
<li>x<del>1</del>：1$\oplus$0$\oplus$1$\oplus$1=1</li>
</ul>
<p>则发生错误的位号为x<del>4</del>x<del>2</del>x<del>1</del>：101=5</p>
</li>
</ul>
</li>
</ol>
<h2>流量控制与可靠传输机制</h2>
<h3>流量控制与滑动窗口机制</h3>
<ol>
<li>流量控制：由接收方控制发送方的发送速率，使接收方有足够的缓存空间来接受每个帧</li>
<li>常见的流量控制方法有两种：
<ul>
<li>停止-等待协议</li>
<li>滑动窗口协议</li>
</ul>
</li>
<li>数据链路层和传输层都有流量控制功能，且都用到了滑动窗口协议，区别是
<ul>
<li>数据链路层控制的是相邻节点之间的流量，而传输层控制的是端到端的流量</li>
<li>数据链路层的控制手段是接收方收不下就不返回确认。传输层的控制手段是接收方通过确认报文段中的窗口值来调整发送方的发送窗口</li>
</ul>
</li>
<li>停止-等待流量控制基本原理
<ul>
<li>发送方每次只允许发送一个帧，接收方每接收一个帧都要反馈一个应答信号，表示可以接受下一帧，发送方收到应答信号后才能发送下一帧；若接收方没有收到接收方反馈的应答信号，则需要一直等待</li>
<li>发送方每发送完一个帧，就进入等待接受方确认信息的过程中，因此传输效率低</li>
</ul>
</li>
<li>滑动窗口流量控制基本原理
<ul>
<li>在任意时刻，发送方都要维持一组连续的允许发送帧的序号，称为发送窗口；接收方也维持一组连续的允许接受帧的序号，称为接收窗口</li>
<li>发送窗口表示在未收到对方确认消息的情况下，发送方最多还能发送多少帧和哪些帧；接收窗口表示可以接收哪些帧和不可以接收哪些帧</li>
<li>发送方每收到一个按序确认的确认帧，就将发送窗口向前滑动一个位置，同时就有一个新的序号落入发送窗口，序号落入发送窗口内的数据帧就可以继续发送。当窗口内没有可以发送的帧时，发送方就停止发送</li>
<li>滑动窗口的特性：
<ul>
<li>只有接收窗口向前滑动时，发送窗口才有可能向前滑动</li>
<li>当接收窗口大小为1时，可保证帧的有序接收</li>
<li>在数据链路层的滑动窗口协议中，窗口大小在传输过程中是固定的，而在传输层的滑动窗口协议中，窗口大小不是固定的</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3>可靠传输机制</h3>
<ol>
<li>
<p>可靠传输：发送方发送的数据都能被接收方正确地接收</p>
</li>
<li>
<p>自动重传请求ARQ：使用确认和超时重传两种机制的可靠传输协议</p>
<ul>
<li>确认：接收方每收到发送方发来的数据帧，都要向发送方发回一个确认帧</li>
<li>超时重传：发送方在发送一个数据帧后就启动一个计时器，若在规定时间内没有收到所发送数据帧的确认帧，则重发该数据帧</li>
</ul>
</li>
<li>
<p>停止等待协议</p>
<ul>
<li>发送方每次只能发送一个帧，当发送方收到接收方的确认帧后，才能发送下一帧</li>
<li>发送窗口和接收窗口大小均为1</li>
<li>可能出现的差错：
<ul>
<li>帧丢失</li>
<li>到达接收方的数据帧可能已遭到破坏，接收方利用差错检测技术检出后，将帧丢弃。发送方计时器超时后，重发该数据帧</li>
<li>数据帧正确而确认帧被破坏，此时接收方已收到正确的数据帧，但发送方收不到确认帧，因此发送方会重传已被接收的数据帧，接收方收到相同的数据帧时丢弃该帧，并重传一个该帧对应的确认帧</li>
</ul>
</li>
<li>发送方发送数据帧后，需在缓存中保留该数据帧的副本，这样才能在出现差错时进行重传。只有接收到对应的确认帧后，才会清除该副本</li>
</ul>
</li>
<li>
<p>后退N帧协议</p>
<ul>
<li>发送方发送N个数据帧后，若发现这N个帧的某个数据帧在计时器超时后仍未收到确认消息，则认为该帧出错或丢失，此时发送方不得不重传该数据帧以及后面的帧</li>
<li>接收方只能按顺序接收帧</li>
<li>GBN协议允许接收方进行累积确认，即对某个数据帧的确认就代表该数据帧以及之前所有帧的确认</li>
<li>若采用n比特对帧编号，则发送窗口W<del>T</del>应满足1＜W<del>T</del>≤2^n^-1，超过则会导致接收方无法分辨新数据帧和旧数据帧</li>
</ul>
</li>
<li>
<p>选择重传协议</p>
<ul>
<li>
<p>对每个正确接受的数据帧进行确认</p>
</li>
<li>
<p>接收方需要设置足够的帧缓冲区来暂存那些失序但是正确到达且序号在接收窗口内的数据帧</p>
</li>
<li>
<p>一旦接收方检测到某个数据帧出错，就向发送方发送一个否定帧NTK，要求发送方立即重传NAK指定的数据帧</p>
</li>
<li>
<p>接收窗口W<del>R</del>和发送窗口W<del>T</del>大小满足要求：</p>
<ul>
<li>W<del>R</del>+W<del>T</del>≤2^n^</li>
<li>W<del>R</del>≤W<del>T</del>
</li>
</ul>
<blockquote>
<p>一般情况下，W<del>R</del>和W<del>T</del>大小是相同的</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>信道利用率：发送方在一个发送周期内，有效发送数据时间与整个发送周期之比</p>
<ul>
<li>S-W：U=$\frac{T_D}{T_D+RTT+T_A}$，其中T<del>D</del>表示发送方发送数据帧的发送时延，RTT表示往返时延，T<del>A</del>表示接收方发送确认帧的发送时延</li>
<li>GBN/SR：U=min($\frac{nT_D}{T_D+RTT+T_A},1$)，其中n表示发送窗口大小</li>
</ul>
</li>
</ol>
<h3>错题</h3>
<ol>
<li>
<p>下列情况中，会使停止-等待协议的效率变得很低的是(  )</p>
<p>A. 当源主机和目的主机之间距离很近而且数据传输速率很高时</p>
<p>B. 当源主机和目的主机之间距离很远而且数据传输速率很高时</p>
<p>C. 当源主机和目的主机之间距离很近而且数据传输速率很低时</p>
<p>D. 当源主机和目的主机之间距离很远而且数据传输速率很低时</p>
</li>
<li>
<p>对于选择重传协议，帧采用5位编号，接收窗口大小位14，则发送窗口最大为(  )</p>
<p>A. 14</p>
<p>B. 16</p>
<p>C. 18</p>
<p>D. 31</p>
</li>
<li>
<p>两台主机之间的数据链路层采用GBN传输数据，数据传输速率为16kb/s，单向传播时延为270ms，数据帧长范围是128~512字节，接收方总是以与数据帧等长的帧进行确认。为使信道利用率达到最高，帧序号的比特数至少为(  )</p>
<p>A. 5</p>
<p>B. 4</p>
<p>C. 3</p>
<p>D. 2</p>
</li>
<li>
<p>假设通过同一条信道，数据链路层分别采用S-W、GBN、SR传输数据，三个协议的数据帧长相同，忽略确认帧长，帧序号位数为3比特。若对应三个协议的发送方最大信道利用率分别是U<del>1</del>、U<del>2</del>和U<del>3</del>，则U<del>1</del>、U<del>2</del>和U<del>3</del>满足的关系是(  )</p>
<p>A. U<del>1</del>≤U<del>2</del>≤U<del>3</del></p>
<p>B. U<del>1</del>≤U<del>3</del>≤U<del>2</del></p>
<p>C. U<del>2</del>≤U<del>3</del>≤U<del>1</del></p>
<p>D. U<del>3</del>≤U<del>2</del>≤U<del>1</del></p>
</li>
</ol>
<h2>介质访问控制</h2>
<ol>
<li>介质访问控制的主要任务是：为使用介质的的每个节点隔离来自同一信道上其他节点所传送的信号，以协调活动节点的传输</li>
<li>用来决定广播信道中信道分配的协议属于数据链路层的一个子层，称为介质访问控制子层(MAC)</li>
</ol>
<h3>信道划分介质访问控制</h3>
<ol>
<li>
<p>信道划分介质访问控制的分类：</p>
<div class="highlight highlight-source-mermaid"><pre class="notranslate"><span class="pl-k">graph</span> <span class="pl-c1">LR</span>
	<span class="pl-ent">A</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>分类<span class="pl-pds"><span class="pl-sg">)</span></span></span>
	<span class="pl-ent">A</span><span class="pl-k">--&gt;</span><span class="pl-ent">B</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>频分复用FDM<span class="pl-pds"><span class="pl-sg">)</span></span></span>
	<span class="pl-ent">A</span><span class="pl-k">--&gt;</span><span class="pl-ent">C</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>时分复用TDM<span class="pl-pds"><span class="pl-sg">)</span></span></span>
	<span class="pl-ent">A</span><span class="pl-k">--&gt;</span><span class="pl-ent">D</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>波分复用WDM<span class="pl-pds"><span class="pl-sg">)</span></span></span>
	<span class="pl-ent">A</span><span class="pl-k">--&gt;</span><span class="pl-ent">E</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>码分复用CDM<span class="pl-pds"><span class="pl-sg">)</span></span></span></pre></div>
</li>
<li>
<p>频分复用</p>
<ul>
<li>将信道的总频带划分为多个子频带，每个子频带作为一个子信道，每对用户使用一个子信道进行通信</li>
<li>优点：充分利用了传输介质的带宽，系统效率较高，实现也较容易</li>
</ul>
</li>
<li>
<p>时分复用</p>
<ul>
<li>将信道的传输时间划分为一段段等长的时间片，称为TDM帧，每个用户在每个TDM帧中占用固定序号的时隙</li>
<li>缺点：当用户在某段时间暂无数据传输时，其他用户无法使用这个暂时空闲的资源</li>
<li>改进：STDM，不固定分配时隙，而按需动态分配时隙</li>
</ul>
</li>
<li>
<p>波分复用</p>
<ul>
<li>光的频分复用</li>
</ul>
</li>
<li>
<p>码分复用</p>
<ul>
<li>
<p>采用不同的编码来区分各路原始信号</p>
</li>
<li>
<p>又称码分多址CDMA，将每个比特时间在划分成m个短时间槽，称为码片</p>
</li>
<li>
<p>每个站点被指派一个唯一的m位码片序列。发送1时，站点发送它的码片序列；发送0时，站点发送码片序列的反码。当多个站点同时发送时，各路数据在信道中线性相加</p>
</li>
<li>
<p>要求：各个站点的码片序列相互正交</p>
</li>
<li>
<p>令向量<strong>S</strong>表示A站的码片向量，<strong>T</strong>表示B站的码片向量，则：</p>
<ul>
<li><strong>S</strong>·<strong>T</strong>=0</li>
<li><strong>S</strong>·<strong>S</strong>=1</li>
</ul>
<p>加入A站发送1，B站发送0，则信道中传送的数据为S+(-T)，记为<strong>V</strong>。到达C站之后，进行数据分离：A站传送的数据为<strong>S</strong>·<strong>V</strong>，B站传送的数据为<strong>T</strong>·<strong>V</strong></p>
</li>
</ul>
</li>
</ol>
<h3>随机访问介质访问控制</h3>
<ol>
<li>
<p>当有两个或多个用户同时发送信息时，就会产生帧冲突，导致所有冲突用户的发送均失败。为了解决随机访问发生的冲突，每个用户需要按照一定的规则重传，直到成功发送消息，这些规则就是随机访问介质访问控制协议</p>
</li>
<li>
<p>ALOHA协议</p>
<ul>
<li>纯ALOHA协议
<ul>
<li>当总线形网络中的任何站点需要发送数据时，可以不进行任何检测就发送数据。若在一段时间内未收到确认，则该站点需要等待一段时间重发消息直到成功</li>
<li>发生冲突的各站必须进行重传，但并不能马上重传，而是等待随机时间再进行重传</li>
<li>缺点：吞吐量低</li>
</ul>
</li>
<li>时隙ALOHA协议
<ul>
<li>协议同步各站点的时间，将时间划分为一段段等长的的时隙，规定站点只能在每个时隙开始时才能发送帧</li>
<li>避免了用户发送数据的随意性，降低了产生冲突的可能性，提高了信道的利用率</li>
</ul>
</li>
</ul>
</li>
<li>
<p>CSMA协议</p>
<ul>
<li>
<p>载波监听多路访问CSMA：每个站点在发送前先监听公用信道，发现信道空闲后再发送数据，就会大大降低冲突的可能性，提高信道的利用率</p>
</li>
<li>
<p>根据监听方式和监听到信道忙后的处理方式，CSMA可分为：</p>
<div class="highlight highlight-source-mermaid"><pre class="notranslate"><span class="pl-k">graph</span> <span class="pl-c1">LR</span>
	<span class="pl-ent">A</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>分类<span class="pl-pds"><span class="pl-sg">)</span></span></span>
	<span class="pl-ent">A</span><span class="pl-k">--&gt;</span><span class="pl-ent">B</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>1-坚持CSMA<span class="pl-pds"><span class="pl-sg">)</span></span></span>
	<span class="pl-ent">A</span><span class="pl-k">--&gt;</span><span class="pl-ent">C</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>非坚持CSMA<span class="pl-pds"><span class="pl-sg">)</span></span></span>
	<span class="pl-ent">A</span><span class="pl-k">--&gt;</span><span class="pl-ent">D</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>p-坚持CSMA<span class="pl-pds"><span class="pl-sg">)</span></span></span></pre></div>
<ul>
<li>1-坚持CSAM：当站点要发送数据时，首先监听信道，若信道空闲，则立即发送数据；若信道忙，则继续监听直到信道空闲</li>
<li>非坚持CSMA：当站点要发送数据时，首先监听信道，若信道空闲，则立即发送数据；若信道忙，则放弃监听，等待一个随机的时间后，再随机监听</li>
<li>p-坚持CSAM：只适用于十分信道。当站点要发送数据时，首先监听信道，若信道忙，则持续监听，直到信道空闲；若信道空闲，则以概率p发送数据，以概率1-p推迟到下一个时隙在继续监听，直到数据发送成功</li>
</ul>
</li>
</ul>
</li>
<li>
<p>CSMA/CD协议</p>
<ul>
<li>
<p>载波监听多路访问/冲突检测(CSMA/CD)：适用于总线形网络或半双工网络环境</p>
</li>
<li>
<p>每个站点再发送前和发送过程中都必须不停检测信道，在发送前检测信道是为了获得发送全，在发送过程中检测信道是为了及时发现发送的数据是否发生冲突</p>
</li>
<li>
<p>冲突检测就是边发送边监听，若监听到了冲突，则立即停止数据发送，等待一段随机事件后，重新尝试发送数据</p>
</li>
<li>
<p>一个站点在开始发送数据后最多经过端到端传播时延的2倍($2\tau$)才能直到有没有发生冲突，因此把2$\tau$称为争用期。每个站只有经过争用期还未检测到冲突才能确定这次发送不会产生冲突</p>
</li>
<li>
<p>为了避免帧长太短导致无法检测到冲突，以太网规定了一个最短帧长，最短帧长=总线传播时延$\times$数据传输速率$\times$2</p>
</li>
<li>
<p>重传时机：采用截断二进制指数退避算法</p>
<ul>
<li>确定基本退避时间：一般取2$\tau$</li>
<li>从离散的整数集合[0, 1, ..., (2^k^-1)]中随机取出一个数r，重传所需推迟的时间就是2r$\tau$</li>
</ul>
<blockquote>
<p>注：k = min(重传次数, 10)</p>
</blockquote>
<ul>
<li>当重传次数达到16次还未成功，则抛弃该帧停止发送</li>
</ul>
</li>
</ul>
</li>
<li>
<p>CSMA/CA协议</p>
<ul>
<li>无线信道不能使用CSMA/CD协议的原因</li>
</ul>
<div class="highlight highlight-source-mermaid"><pre class="notranslate"><span class="pl-k">graph</span> <span class="pl-c1">LR</span>
	<span class="pl-ent">A</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>原因<span class="pl-pds"><span class="pl-sg">)</span></span></span>
	<span class="pl-ent">A</span><span class="pl-k">--&gt;</span><span class="pl-ent">B</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>实现冲突检测麻烦<span class="pl-pds"><span class="pl-sg">)</span></span></span>
	<span class="pl-ent">A</span><span class="pl-k">--&gt;</span><span class="pl-ent">C</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>存在“隐蔽站”问题<span class="pl-pds"><span class="pl-sg">)</span></span></span></pre></div>
<ul>
<li>因为无线信道的通信质量远不如有线信道，所以使用链路层确认/重传ARQ方案，即站点没通过无线局域网发送完一帧，就要在收到对方的确认帧后才能继续发送下一帧</li>
<li>所有站完成发送后，必须等待一段时间才能发送下一帧。这一段时间称为帧间间隔IFS</li>
</ul>
<div class="highlight highlight-source-mermaid"><pre class="notranslate"><span class="pl-k">graph</span> <span class="pl-c1">LR</span>
	<span class="pl-ent">A</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>IFS类别<span class="pl-pds"><span class="pl-sg">)</span></span></span>
	<span class="pl-ent">A</span><span class="pl-k">--&gt;</span><span class="pl-ent">B</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>SIFS<span class="pl-pds"><span class="pl-sg">)</span></span></span><span class="pl-k">--&gt;</span><span class="pl-ent">C</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>最短的IFS，用于分隔属于一次对话的帧<span class="pl-pds"><span class="pl-sg">)</span></span></span>
	<span class="pl-ent">A</span><span class="pl-k">--&gt;</span><span class="pl-ent">D</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>PIFS<span class="pl-pds"><span class="pl-sg">)</span></span></span><span class="pl-k">--&gt;</span><span class="pl-ent">E</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>中等长度的IFS，在PCF操作中使用<span class="pl-pds"><span class="pl-sg">)</span></span></span>
	<span class="pl-ent">A</span><span class="pl-k">--&gt;</span><span class="pl-ent">F</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>DIFS<span class="pl-pds"><span class="pl-sg">)</span></span></span><span class="pl-k">--&gt;</span><span class="pl-ent">G</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>最长的IFS，用于异步帧竞争访问的时延<span class="pl-pds"><span class="pl-sg">)</span></span></span></pre></div>
<ul>
<li>虚拟载波监听机制：源站将它要占用的持续时间及时通知给所有其他站，以便所有其他全站在这段时间内都停止发送</li>
<li>当信道从忙态变为空闲时，任何一个站要发送数据帧，不仅要等待一个DIFS的间隔，而且要进入争用窗口，计算随机退避时间以便再次试图访问信道</li>
</ul>
<div class="highlight highlight-source-mermaid"><pre class="notranslate"><span class="pl-k">graph</span> <span class="pl-c1">LR</span>
	<span class="pl-ent">A</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>随机退避<span class="pl-pds"><span class="pl-sg">)</span></span></span>
	<span class="pl-ent">A</span><span class="pl-k">--&gt;</span><span class="pl-ent">B</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>否<span class="pl-pds"><span class="pl-sg">)</span></span></span><span class="pl-k">--&gt;</span><span class="pl-ent">C</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>当前数据帧为第一个数据帧<span class="pl-pds"><span class="pl-sg">)</span></span></span>
	<span class="pl-ent">A</span><span class="pl-k">--&gt;</span><span class="pl-ent">D</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>是<span class="pl-pds"><span class="pl-sg">)</span></span></span>
	<span class="pl-ent">D</span><span class="pl-k">--&gt;</span><span class="pl-ent">E</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>发送第一个帧之前检测到信道忙<span class="pl-pds"><span class="pl-sg">)</span></span></span>
	<span class="pl-ent">D</span><span class="pl-k">--&gt;</span><span class="pl-ent">F</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>每次重传<span class="pl-pds"><span class="pl-sg">)</span></span></span>
	<span class="pl-ent">D</span><span class="pl-k">--&gt;</span><span class="pl-ent">G</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>每次成功发送后发送下一个帧<span class="pl-pds"><span class="pl-sg">)</span></span></span></pre></div>
<div class="highlight highlight-source-mermaid"><pre class="notranslate"><span class="pl-k">graph</span> <span class="pl-c1">LR</span>
	<span class="pl-ent">A</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>需要发送数据帧<span class="pl-pds"><span class="pl-sg">)</span></span></span><span class="pl-k">--&gt;</span><span class="pl-ent">B</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">{</span></span>监听信道<span class="pl-pds"><span class="pl-sg">}</span></span></span><span class="pl-k">--&gt;</span><span class="pl-k">|</span><span class="pl-s">空闲</span><span class="pl-k">|</span><span class="pl-ent">C</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>等待DIFS<span class="pl-pds"><span class="pl-sg">)</span></span></span><span class="pl-k">--&gt;</span><span class="pl-ent">D</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>发送数据帧<span class="pl-pds"><span class="pl-sg">)</span></span></span>
	<span class="pl-ent">B</span><span class="pl-k">--&gt;</span><span class="pl-k">|</span><span class="pl-s">忙</span><span class="pl-k">|</span><span class="pl-ent">E</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>随机退避<span class="pl-pds"><span class="pl-sg">)</span></span></span><span class="pl-k">--&gt;</span><span class="pl-ent">F</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">{</span></span>监听信道<span class="pl-pds"><span class="pl-sg">}</span></span></span><span class="pl-k">--&gt;</span><span class="pl-k">|</span><span class="pl-s">忙</span><span class="pl-k">|</span><span class="pl-ent">G</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>计时器不变<span class="pl-pds"><span class="pl-sg">)</span></span></span>
	<span class="pl-ent">F</span><span class="pl-k">--&gt;</span><span class="pl-k">|</span><span class="pl-s">空闲</span><span class="pl-k">|</span><span class="pl-ent">H</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>计时器启动<span class="pl-pds"><span class="pl-sg">)</span></span></span><span class="pl-k">--&gt;</span><span class="pl-ent">D</span>
	<span class="pl-ent">D</span><span class="pl-k">--&gt;</span><span class="pl-ent">I</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">{</span></span>等待确认<span class="pl-pds"><span class="pl-sg">}</span></span></span><span class="pl-k">--&gt;</span><span class="pl-k">|</span><span class="pl-s">确认</span><span class="pl-k">|</span><span class="pl-ent">J</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>发送成功<span class="pl-pds"><span class="pl-sg">)</span></span></span>
	<span class="pl-ent">I</span><span class="pl-k">--&gt;</span><span class="pl-k">|</span><span class="pl-s">未确认</span><span class="pl-k">|</span><span class="pl-ent">E</span></pre></div>
<ul>
<li>如何解决隐蔽站问题：对信道进行预约</li>
</ul>
<div class="highlight highlight-source-mermaid"><pre class="notranslate"><span class="pl-k">graph</span> <span class="pl-c1">TB</span>
	广播请求<span class="pl-k">--&gt;</span>允许发送<span class="pl-k">--&gt;</span>发送<span class="pl-k">--&gt;</span>确认接收
	
	<span class="pl-k">subgraph</span> 广播请求
		<span class="pl-k">direction</span> <span class="pl-c1">LR</span>
		监听信道<span class="pl-k">--&gt;</span><span class="pl-k">|</span><span class="pl-s">空闲</span><span class="pl-k">|</span>发送<span class="pl-ent">RTS</span>帧
	<span class="pl-k">end</span>
	
	<span class="pl-k">subgraph</span> 允许发送
		<span class="pl-k">direction</span> <span class="pl-c1">LR</span>
		<span class="pl-ent">AP</span>收到<span class="pl-ent">RTS</span>帧<span class="pl-k">--&gt;</span><span class="pl-ent">A</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">[</span></span>等待SIFS<span class="pl-pds"><span class="pl-sg">]</span></span></span>
		信道空闲<span class="pl-k">--&gt;</span><span class="pl-ent">A</span><span class="pl-k">--&gt;</span>发送<span class="pl-ent">CTS</span>帧
	<span class="pl-k">end</span>
	
	<span class="pl-k">subgraph</span> 发送
		<span class="pl-k">direction</span> <span class="pl-c1">LR</span>
		源站收到<span class="pl-ent">CTS</span>帧<span class="pl-k">--&gt;</span><span class="pl-ent">B</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">[</span></span>等待SIFS<span class="pl-pds"><span class="pl-sg">]</span></span></span><span class="pl-k">--&gt;</span>发送数据帧
	<span class="pl-k">end</span>
	
	<span class="pl-k">subgraph</span> 确认接收
		<span class="pl-k">direction</span> <span class="pl-c1">LR</span>
		<span class="pl-ent">AP</span>正确接收<span class="pl-k">--&gt;</span><span class="pl-ent">C</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">[</span></span>等待SIFS<span class="pl-pds"><span class="pl-sg">]</span></span></span><span class="pl-k">--&gt;</span>发送<span class="pl-ent">ACK</span>帧
	<span class="pl-k">end</span></pre></div>
<blockquote>
<p>注：</p>
<ul>
<li>在AP覆盖范围内的其他站听到CTS帧后，将在CTS帧中指明的时间内抑制发送</li>
<li>RTS帧中时间 = SIFS + CTS + SIFS + 数据帧 + SIFS + ACK</li>
<li>CTS帧中时间 = SIFS + 数据帧 + SIFS + ACK</li>
</ul>
</blockquote>
</li>
<li>
<p>CSMA/CD与CSMA/CA的对比</p>
<table role="table">
<thead>
<tr>
<th align="center">协议</th>
<th align="center">冲突解决方式</th>
<th align="center">传输介质</th>
<th align="center">检测方式</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">CSMA/CD</td>
<td align="center">检测冲突，但无法避免</td>
<td align="center">用于总线形以太网</td>
<td align="center">通过电缆中电压</td>
</tr>
<tr>
<td align="center">CSMA/CA</td>
<td align="center">避免冲突</td>
<td align="center">用于无线局域网</td>
<td align="center">通过能量检测、载波检测和能量载波混合检测</td>
</tr>
</tbody>
</table>
</li>
</ol>
<h3>轮询访问：令牌传递协议</h3>
<ol>
<li>用户不能随机地发送信息，而要通过一个集中控制的监控站，以循环方式轮询每个节点，再决定信道的分配</li>
<li>令牌传递协议
<ul>
<li>一个令牌沿着环形总线在各站之间依次传递</li>
<li>令牌是一个不包含信息的特殊的控制帧，仅控制信道的使用，确保同一时刻只有一个站独占信道</li>
<li>站点希望发送帧是，必须等待令牌，只有取得令牌后才能发送帧。站点发送完一帧后，应释放令牌，以便让其他站使用</li>
<li>令牌和数据传递过程：
<ul>
<li>当网络空闲时，只有令牌帧在循环传递</li>
<li>当令牌传递到有数据要发送的站点时，该站点就修改令牌中的标志位，并在令牌附加自己需要传递的数据然后发送出去</li>
<li>令牌继续循环传递，并检查数据帧地目的地址，若与当前位置相同，则接收站接收消息</li>
<li>令牌继续传输，直到到达源站点，令牌不再转发。同时源站点检测返回的令牌是否出错，若出错则重传</li>
<li>源站点传送完数据后，重新产生一个令牌，并传递给下一站点，交出信道控制权</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2>局域网</h2>
<h3>基本概念</h3>
<ol>
<li>
<p>局域网的特点：</p>
<ul>
<li>为一个单位所拥有，且地理范围和站点数目均有限</li>
<li>所有站点共享较高的带宽</li>
<li>较低的时延和较低的误码率</li>
<li>各站位平等关系</li>
<li>能进行广播和多播</li>
</ul>
</li>
<li>
<p>局域网的特性主要由三个要素决定：拓扑结构、传输介质、介质访问控制方式(最重要)</p>
</li>
<li>
<p>局域网主要拓扑结构：</p>
<ul>
<li>星形结构</li>
<li>环形结构</li>
<li>总线形结构</li>
<li>星形结构和总线形结构的复合型结构</li>
</ul>
</li>
<li>
<p>局域网的介质访问控制方式主要有CSMA/CD协议(总线形局域网)、令牌总线协议(总线形局域网)、令牌环协议(环形局域网)</p>
</li>
<li>
<p>三种特殊的局域网拓扑实现：</p>
<markdown-accessiblity-table><table role="table">
<thead>
<tr>
<th align="center">局域网</th>
<th align="center">逻辑拓扑</th>
<th align="center">物理拓扑</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">以太网</td>
<td align="center">总线形结构</td>
<td align="center">星形结构</td>
</tr>
<tr>
<td align="center">令牌环</td>
<td align="center">环形结构</td>
<td align="center">星形结构</td>
</tr>
<tr>
<td align="center">FDDI</td>
<td align="center">环形结构</td>
<td align="center">双环结构</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
</li>
<li>
<p>IEEE 802标准将数据链路层拆分成两个子层：</p>
<ul>
<li>逻辑链路子层(LLC)：与传输介质无关，向网络层提供无确认无连接、面向连接、带确认无连接、告诉传送四种不同的连接服务类型</li>
<li>介质访问控制子层(MAC)：存放与传入传输介质有关的内容，向上层屏蔽对物理层访问的各种差异，包括：组帧和拆卸帧、比特传输差错检测、透明传输</li>
</ul>
</li>
</ol>
<h3>以太网与IEEE 802.3</h3>
<ol>
<li>
<p>以太网逻辑上采用总线形拓扑结构，信息以广播方式发送，使用CSMA/CD方式对总线进行访问控制</p>
</li>
<li>
<p>以太网简化通信方式：</p>
<ul>
<li>采用无连接的工作方式，既不对发送的数据帧编号，又不要求接收方确认。即提供不可靠服务，对差错的纠正由高层完成</li>
<li>发送的数据使用曼彻斯特编码的信号，用于同步</li>
</ul>
</li>
<li>
<p>网络适配器</p>
<ul>
<li>用于计算机与外界局域网的连接，进行数据的串并转换</li>
<li>装有处理器和存储器，工作在数据链路层</li>
<li>适配器与局域网的通信通过电缆或双绞线以串行方式进行</li>
<li>适配器和计算机的通信通过计算机的I/O总线以并行方式进行</li>
<li>当适配器收到正确的帧时，使用中断通知计算机，并交付协议栈中的网络层；当计算机要发送IP数据报时，由协议栈把IP数据报向下交给适配器，组帧后发送到局域网</li>
</ul>
</li>
<li>
<p>MAC地址</p>
<ul>
<li>局域网上的每台计算机中固化在适配器的ROM中的地址</li>
<li>用于控制主机在网络上的数据通信</li>
<li>长度：48位，一般由连字符连接十二个十六进制数表示，如：02-60-8c-e4-bb-21</li>
<li>当路由器通过适配器连接到局域网时，适配器上的MAC地址就用来标志路由器的某个接口</li>
<li>适配器从网络上每收到一个MAC帧，首先检查MAC帧中的目的地址，若属于以下三种情况则接收：
<ul>
<li>单播帧：收到的帧的目的地址与本站的MAC地址相同</li>
<li>广播帧：发送给本局域网上所有的站点</li>
<li>多播帧：发送给本局域网上一部分站点的帧</li>
</ul>
</li>
</ul>
</li>
<li>
<p>MAC帧：</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/f8bd4af315d38f3b3dad3d1442742691847ce4266dcce0f1c42d352c05b59016/68747470733a2f2f74656c6567726170682d696d6167652d3662342e70616765732e6465762f66696c652f3336323932306336366566643061393638636462642e706e67"><img src="https://camo.githubusercontent.com/f8bd4af315d38f3b3dad3d1442742691847ce4266dcce0f1c42d352c05b59016/68747470733a2f2f74656c6567726170682d696d6167652d3662342e70616765732e6465762f66696c652f3336323932306336366566643061393638636462642e706e67" alt="flower" data-canonical-src="https://telegraph-image-6b4.pages.dev/file/362920c66efd0a968cdbd.png" style="max-width: 100%;"></a></p>
<ul>
<li>8字节的前导码分为两部分：7字节的前同步码用于实现MAC帧的比特同步，1字节的帧开始定界符，用于表示后面的信息就是MAC帧</li>
<li>目的地址：6字节，帧在局域网上的目的适配器的MAC地址</li>
<li>源地址：6字节，传输帧到局域网上的源适配器的MAC地址</li>
<li>类型：2字节，指出数据字段的数据应交给哪个上层协议处理</li>
<li>数据字段：46~1500字节，承载上层的协议数据单元。以太网的最大传输单元是1500字节，若IP数据报超过1500字节，则必须将IP数据报分片。由于CSMA/CD算法的限制，以太网帧长必须≥64字节，当数据字段的长度小于46字节时，MAC子层就在数据字段的后面填充字段</li>
<li>检验码(FCS)：4字节，检验范围从目的地址段到数据字段，算法采用32位CRC码，不但要检验MAC帧的数据部分，还要检验目的地址、源地址和类型字段，但不包含前导码</li>
</ul>
</li>
<li>
<p>高速以太网</p>
<markdown-accessiblity-table><table role="table">
<thead>
<tr>
<th align="center">标准</th>
<th align="center">传输速率</th>
<th align="center">传输介质</th>
<th align="center">通信方式</th>
<th align="center">介质访问控制协议</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">100Base-T以太网</td>
<td align="center">100Mb/s</td>
<td align="center">双绞线</td>
<td align="center">半/全双工通信</td>
<td align="center">CSMA/CD</td>
</tr>
<tr>
<td align="center">吉比特以太网</td>
<td align="center">1Gb/s</td>
<td align="center">双绞线/光纤</td>
<td align="center">半/全双工通信</td>
<td align="center">CSMA/CD</td>
</tr>
<tr>
<td align="center">10吉比特以太网</td>
<td align="center">10Gb/s</td>
<td align="center">双绞线/光纤</td>
<td align="center">全双工通信</td>
<td align="center">-</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<blockquote>
<p>CSMS/CD协议只在半双工通信方式下才适用</p>
</blockquote>
</li>
</ol>
<h3>IEEE 802.11 无线局域网</h3>
<ol>
<li>
<p>无线局域网可分为两大类：</p>
<ul>
<li>有固定基础设施的无线局域网</li>
<li>无固定基础设置的移动自组织网络</li>
</ul>
</li>
<li>
<p>有固定基础设施的无线局域网</p>
<ul>
<li>使用802.11协议，标准使用星形拓扑，其中心称为接入点AP，在MAC层使用CSMA/CA协议</li>
<li>使用802.11系列协议的局域网又称为Wi-Fi</li>
<li>802.11标准规定无线局域网的最小构件是基本服务集(BSS)</li>
<li>一个基本服务集包括一个接入点和若干移动站</li>
<li>各个站点在本BSS内的通信或与本BSS外部站的通信，都必须通过本BSS的AP</li>
<li>安装AP时，必须为其分配一个不超过32字节的服务集标识符(SSID，使用该AP的无线局域网的名称)和一个信道</li>
</ul>
</li>
<li>
<p>无固定基础设施移动自组织网络</p>
<ul>
<li>没有基本服务集中的AP，而由一些平等状态的移动站相互通信组成临时网络。各节点之间地位平等，中间节点都是转发节点，都具有路由器功能</li>
</ul>
</li>
<li>
<p>802.11局域网的MAC帧</p>
<ul>
<li>
<p>802.11帧有三种类型：数据帧、控制帧和管理帧</p>
</li>
<li>
<p>数据帧的组成部分：</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/ad496626d2e734bc2f31f091b8bfc39251be3c012ef331c61b809a8e8e79fe12/68747470733a2f2f74656c6567726170682d696d6167652d3662342e70616765732e6465762f66696c652f6639633730643066623265353132663064313539372e706e67"><img src="https://camo.githubusercontent.com/ad496626d2e734bc2f31f091b8bfc39251be3c012ef331c61b809a8e8e79fe12/68747470733a2f2f74656c6567726170682d696d6167652d3662342e70616765732e6465762f66696c652f6639633730643066623265353132663064313539372e706e67" alt="flower" data-canonical-src="https://telegraph-image-6b4.pages.dev/file/f9c70d0fb2e512f0d1597.png" style="max-width: 100%;"></a></p>
<ul>
<li>MAC首部：共30字节</li>
<li>帧主体：帧的数据部分，不超过2312字节</li>
<li>帧检验序列FCS：MAC尾部，共4字节</li>
<li>地址1：接收端AP的MAC地址；地址2：发送端AP的MAC地址；地址3：目的设备MAC地址；地址4：原设备MAC地址</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3>VLAN基本概念与基本原理</h3>
<ol>
<li>虚拟局域网可以将一个较大的局域网分割成一些较小的与地理位置无关的逻辑上的VLAN，而每个VLAN是一个较小的广播域</li>
<li>划分VLAN的方式：
<ul>
<li>基于接口：将交换机的若干接口划分为一个逻辑组</li>
<li>基于MAC地址：按MAC地址将一些主机划分为一个逻辑子网，当主机的物理位置从一个交换机移动到另一个交换机时，它仍属于原来的子网</li>
<li>基于IP地址：根据网络层地址或协议划分VLAN，可以跨越路由器进行扩展，将多个局域网的主机连接在一起</li>
</ul>
</li>
<li>以太网帧格式：在以太网帧中插入一个4字节的标识符(插在源地址字段和类型字段之间)，称为VLAN标签，用来指明发送该帧的计算机属于哪个虚拟局域网
<ul>
<li>VLAN标签的前两个字节总是置为0x8100，表示这是一个802.1Q帧</li>
<li>VLAN标签后两个字节前4位没有实际意义</li>
<li>VLAN标签后两个字节后12位是该VLAN的标识符VID，唯一表示该802.1Q帧属于哪个VLAN</li>
<li>插入VLAN标签后FCS需要重新计算</li>
</ul>
</li>
<li>数据帧传递过程(假定A和B属于同一个虚拟局域网，且连接在同一个交换机下，A与C属于同一个虚拟局域网，但未连接在同一个交换机下)：
<ul>
<li>A向B发送帧，交换机根据帧首部的MAC地址，识别B属于本交换机管理，且与A位于同一VLAN，则像在普通以太网中一样直接转发帧</li>
<li>A向C发送帧，交换机根据帧首部的MAC地址，识别B不属于本交换机管理，且与A位于同一VLAN，则向帧中插入VLAN标签，然后将帧转发给C对应的交换机</li>
<li>C对应的交换机接收到帧之后删掉VLAN标签，然后直接转发帧</li>
</ul>
</li>
</ol>
<h2>广域网</h2>
<h3>基本概念</h3>
<ol>
<li>广域网：覆盖范围很广的长距离网络，任务是长距离传输数据</li>
<li>广域网由一些节点交换机及连接这些交换机的链路组成</li>
</ol>
<blockquote>
<p>节点交换机：在单个网络中转发分组</p>
<p>路由器：在多个网络构成的互联网中转发分组</p>
</blockquote>
<ol start="3">
<li>
<p>局域网与广域网的区别：</p>
<markdown-accessiblity-table><table role="table">
<thead>
<tr>
<th align="center"></th>
<th align="center">广域网</th>
<th align="center">局域网</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">覆盖范围</td>
<td align="center">很广</td>
<td align="center">很小</td>
</tr>
<tr>
<td align="center">链接方式</td>
<td align="center">通常采用点对点连接</td>
<td align="center">普遍采用广播信道</td>
</tr>
<tr>
<td align="center">OSI模型层次</td>
<td align="center">物理层，数据链路层，网络层</td>
<td align="center">物理层，数据链路层</td>
</tr>
<tr>
<td align="center">重点</td>
<td align="center">资源共享</td>
<td align="center">数据传输</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
</li>
</ol>
<h3>PPP协议</h3>
<ol>
<li>
<p>点对点协议PPP的三个组成部分：</p>
<ul>
<li>一个链路控制协议LCP：用来建立、配置、测试数据链路连接，以及协商一些选项</li>
<li>一套网络控制协议NCP：采用多种网络层协议，每个不同网络层协议要用一个相应的NCP配置，为网络层协议建立和配置逻辑连接</li>
<li>一种将IP数据报封装到串行链路的方法：IP数据报在PPP帧中就是其信息部分，这个信息部分的长度受最大传送单元MTU限制</li>
</ul>
</li>
<li>
<p>PPP帧的格式为：</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/b81cf47df0aceeff4ff3a036e4b26857809952b6e569a238c8ec9bc333436b31/68747470733a2f2f74656c6567726170682d696d6167652d3662342e70616765732e6465762f66696c652f3866663733336538386237313930646536326336312e706e67"><img src="https://camo.githubusercontent.com/b81cf47df0aceeff4ff3a036e4b26857809952b6e569a238c8ec9bc333436b31/68747470733a2f2f74656c6567726170682d696d6167652d3662342e70616765732e6465762f66696c652f3866663733336538386237313930646536326336312e706e67" alt="flower" data-canonical-src="https://telegraph-image-6b4.pages.dev/file/8ff733e88b7190de62c61.png" style="max-width: 100%;"></a></p>
<ul>
<li>首部和尾部各有一个标识字段(F)，规定为0x7E，表示一个帧的开始和结束</li>
<li>地址字段(A)占一个字节，规定为0xFF，控制字段(C)占一个字节，规定为0x03</li>
<li>PPP帧的长度都是整数个字节</li>
<li>协议段占两个字节，表示信息段运载的分组的种类</li>
<li>帧检验字段(FCS)是使用CRC检验的冗余码</li>
</ul>
</li>
<li>
<p>PPP协议的特点：</p>
<ul>
<li>PPP不适用序号和确认机制，只保证无差错接受，因此是不可靠服务</li>
<li>PPP只支持全双工的点对点链路，不支持多点线路</li>
<li>PPP的两端可以运行不同的网络层协议，但是仍可使用同一PPP进行通信</li>
<li>PPP是面向字节的，因此PPP帧的长度都是整数个字节</li>
</ul>
</li>
</ol>
<h2>数据链路层的设备</h2>
<h3>以太网交换机</h3>
<ol>
<li>由于以太网交换机工作在数据链路层，因此以太网交换机又称为二层交换机</li>
<li>以太网交换机特点：
<ul>
<li>当交换机的接口直接与主机或者其他交换机连接时，可工作在全双工方式，并能同时连通多对接口，使每对相互通信的主机都能像独占通信介质那样，无冲突地传输数据，这样就不需要使用CSMA/CD协议</li>
<li>当交换机的接口连接集线器时，只能使用CSMA/CD协议且只能工作在半双工方式</li>
<li>交换机是一种即插即用设备，其内部帧转发表是通过自学习算法，基于网络中各主机间的通信，自动逐渐建立</li>
<li>交换机因为使用专用交换结构芯片，交换速率较高</li>
<li>交换机独占传输介质的带宽</li>
</ul>
</li>
<li>以太网交换机主要采用两种交换模式：
<ul>
<li>直通交换方式
<ul>
<li>原理：只检查帧的目的MAC地址，以决定该帧的转发接口</li>
<li>优点：传输时延小</li>
<li>缺点：不检查差错就直接发送，可能将一些无效帧转发给其他站</li>
<li>适用性：不适用于需要速率匹配、协议转换或差错检测的线路</li>
</ul>
</li>
<li>存储转发交换方式
<ul>
<li>原理：先将接收到的帧缓存到高速缓存器，并检查数据是否正确，确认无误后通过查找表转换为输出接口，以便将该帧转发出去。若发现帧出错，则将其丢弃</li>
<li>优点：可靠性高，且能支持不同速率接口间的转换</li>
<li>缺点：时延大</li>
</ul>
</li>
</ul>
</li>
<li>以太网交换机的自学习能力
<ul>
<li>过滤：决定一个帧是转发到某个接口还是丢弃，需要用到交换表</li>
<li>转移：决定一个帧应被移至哪个接口，需要用到交换表</li>
<li>交换表中的表项至少需要包含：
<ul>
<li>一个MAC地址</li>
<li>连通该MAC地址的接口</li>
<li>……</li>
</ul>
</li>
<li>自学习过程
<ul>
<li>源地址A发送消息</li>
<li>记录源地址A与其对应接口</li>
<li>若交换表中有目的地址信息直接转发</li>
<li>若交换表中没有目的地址信息，则从除了源地址对应的接口外所有接口广播</li>
<li>非目的地址主机丢弃帧，目的地址主机接收该帧</li>
</ul>
</li>
</ul>
</li>
<li>共享式以太网和交换式以太网的对比
<ul>
<li>当主机发送普通帧时
<ul>
<li>对于共享式以太网，集线器将帧转发到其他所有接口，其他各主机中的网卡根据帧的目的MAC地址决定接收或丢弃该帧</li>
<li>对于交换式以太网，交换机收到帧后，根据帧的目的MAC地址和自身的交换表将帧明确地转发给目的主机</li>
</ul>
</li>
<li>当主机发送广播帧时：
<ul>
<li>对于共享式以太网，集线器将帧转发到其他所有接口，其他各主机中的网卡检测到帧的目的MAC地址时广播地址时，就接收该帧</li>
<li>对于交换式以太网，交换机检测到目的MAC地址是广播地址，于是从其他所有接口转发该帧，其他各主机收到该广播帧后，就接受该帧</li>
</ul>
</li>
<li>多对主机同时通信时：
<ul>
<li>对于共享式以太网，必然会产生冲突</li>
<li>对于交换式以太网，交换机能实现多对接口的高速并行交换，因此不会产生冲突</li>
</ul>
</li>
</ul>
</li>
</ol></div>
<div style="font-size:small;margin-top:8px;float:right;"></div>

<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>

</div>
    <div id="footer"><div id="footer1">Copyright © <span id="copyrightYear"></span> <a href="https://wlkla.github.io/onebuaaer.github.io">我在人世间踽踽独行</a></div>
<div id="footer2">
    <span id="runday"></span><span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a></span>
</div>

<script>
var now=new Date();
document.getElementById("copyrightYear").innerHTML=now.getFullYear();

if("09/02/2024"!=""){
    var startSite=new Date("09/02/2024");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";
}
</script></div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z', 'copy': 'M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z', 'check': 'M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);



function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","wlkla/onebuaaer.github.io");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const createClipboardHTML = (codeContent, additionalClasses = '') => `
        <pre class="notranslate"><code class="notranslate">${codeContent}</code></pre>
        <div class="clipboard-container position-absolute right-0 top-0 ${additionalClasses}">
            <clipboard-copy class="ClipboardButton btn m-2 p-0" role="button" style="display: inherit;">
                <svg height="16" width="16" class="octicon octicon-copy m-2"><path d="${IconList["copy"]}"></path></svg>
                <svg height="16" width="16" class="octicon octicon-check color-fg-success m-2 d-none"><path d="${IconList["check"]}"></path></svg>
            </clipboard-copy>
            <div class="copy-feedback">Copied!</div>
        </div>
    `;

    const handleCodeElements = (selector = '') => {
        document.querySelectorAll(selector).forEach(codeElement => {
            const codeContent = codeElement.innerHTML;
            const newStructure = document.createElement('div');
            newStructure.className = 'snippet-clipboard-content position-relative overflow-auto';
            newStructure.innerHTML = createClipboardHTML(codeContent);

            const parentElement = codeElement.parentElement;
            if (selector.includes('highlight')) {
                parentElement.insertBefore(newStructure, codeElement.nextSibling);
                parentElement.removeChild(codeElement);
            } else {
                parentElement.parentElement.replaceChild(newStructure, parentElement);
            }
        });
    };

    handleCodeElements('pre.notranslate > code.notranslate');
    handleCodeElements('div.highlight > pre.notranslate');

    let currentFeedback = null;
    document.querySelectorAll('clipboard-copy').forEach(copyButton => {
        copyButton.addEventListener('click', () => {
            const codeContent = copyButton.closest('.snippet-clipboard-content').innerText;
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = codeContent;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            document.execCommand('copy');
            document.body.removeChild(tempTextArea);

            const copyIcon = copyButton.querySelector('.octicon-copy');
            const checkIcon = copyButton.querySelector('.octicon-check');
            const copyFeedback = copyButton.nextElementSibling;

            if (currentFeedback && currentFeedback !== copyFeedback) {currentFeedback.style.display = 'none';}
            currentFeedback = copyFeedback;

            copyIcon.classList.add('d-none');
            checkIcon.classList.remove('d-none');
            copyFeedback.style.display = 'block';
            copyButton.style.borderColor = 'var(--color-success-fg)';

            setTimeout(() => {
                copyIcon.classList.remove('d-none');
                checkIcon.classList.add('d-none');
                copyFeedback.style.display = 'none';
                copyButton.style.borderColor = '';
            }, 2000);
        });
    });
});

</script>
<script src='https://blog.meekdai.com/Gmeek/plugins/articletoc.js'></script><script src='https://blog.meekdai.com/Gmeek/plugins/lightbox.js'></script><script>MathJax = {tex: {inlineMath: [["$", "$"]]}};</script><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

</html>
