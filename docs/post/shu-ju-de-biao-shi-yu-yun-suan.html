<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    <script src='https://onebuaaer.us.kg/assets/theme.js'>
    <link rel="icon" href="https://telegraph-image-6b4.pages.dev/file/3a89e862ad5a60a260608.jpg"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="# 第二章：数据的表示与运算

## 数制与编码

### 进位计数制及其相互转换

1. 在进位计数法中，每个数位所用到的不同数码的个数称为`基数`。">
<meta property="og:title" content="数据的表示与运算">
<meta property="og:description" content="# 第二章：数据的表示与运算

## 数制与编码

### 进位计数制及其相互转换

1. 在进位计数法中，每个数位所用到的不同数码的个数称为`基数`。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://wlkla.github.io/onebuaaer.github.io/post/shu-ju-de-biao-shi-yu-yun-suan.html">
<meta property="og:image" content="https://telegraph-image-6b4.pages.dev/file/3a89e862ad5a60a260608.jpg">
<title>数据的表示与运算</title>
<link href="//unpkg.com/@wooorm/starry-night@2.1.1/style/both.css" rel="stylesheet" />


</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
.copy-feedback {
    display: none;
    position: absolute;
    top: 10px;
    right: 50px;
    color: var(--color-fg-on-emphasis);
    background-color: var(--color-fg-muted);
    border-radius: 3px;
    padding: 5px 8px;
    font-size: 12px;
}
</style>




<body>
    <div id="header">
<h1 class="postTitle">数据的表示与运算</h1>
<div class="title-right">
    <a href="https://wlkla.github.io/onebuaaer.github.io" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/wlkla/onebuaaer.github.io/issues/14" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><h1>第二章：数据的表示与运算</h1>
<h2>数制与编码</h2>
<h3>进位计数制及其相互转换</h3>
<ol>
<li>
<p>在进位计数法中，每个数位所用到的不同数码的个数称为<code class="notranslate">基数</code>。</p>
</li>
<li>
<p>用B表示二进制，用O表示八进制，用D表示十进制，用H表示十六进制，有时也用前缀0x表示十六进制数。</p>
</li>
<li>
<p>进制数之间的转换：</p>
<ul>
<li>二进制转八进制：从小数点前后，以每三位为一组直接转为对应的值；</li>
<li>八进制转二进制：将每一位直接转为对应的二进制表示；</li>
<li>二进制转十六进制：从小数点前后，以每三位为一组直接转为对应的值；</li>
<li>十六进制转二进制：将每一位直接转为对应的二进制表示；</li>
<li>任意进制转十进制：各个数码与对应的权值相乘再相加。</li>
<li>十进制转二进制：对整数部分采用除基取余法，对小数部分采用乘基取整法。</li>
</ul>
</li>
<li>
<p>并不是每个十进制小数都可以准确地用二进制表示，但是任意一个二进制小数都可以用十进制小数表示。</p>
</li>
</ol>
<h3>定点数的编码表示</h3>
<ol>
<li>
<p>真值和机器数<br>
带“+”和“-”符号的数称为真值；<br>
将符号数字化的数称为机器数，通常用“0”表示“+”，用“1”表示“-”。</p>
</li>
<li>
<p>机器数的定点表示</p>
<ul>
<li>定点小数：纯小数，约定小数点位置在符号位之后、有效数值部分最高位之前。</li>
<li>定点整数：纯整数，约定小数点位置在有效数值部分最低位之后。</li>
</ul>
</li>
<li>
<p>原码表示法：</p>
<ul>
<li>用机器数的最高位表示数的符号，其余分为表示数的绝对值。<br>
例如对于14和-14，$[14]_原=\bold{0},0001110,[-14]_原=\bold{1},0001110$</li>
<li>若字长为n+1，则原码整数的表示范围为$-(2^n-1)\leqslant x\leqslant(2^n-1)$</li>
</ul>
</li>
<li>
<p>补码表示法：</p>
<ul>
<li>
<p>正数的补码和原码相同，负数的补码为原码符号位不变，数值为取反，然后再加一。<br>
例如对于14和-14，$[14]_补=\bold{0},0001110,[-14]_补=\bold{1},1110010$</p>
</li>
<li>
<p>若字长为n+1，则补码整数的表示范围为$-(2^n)\leqslant x\leqslant(2^n-1)$</p>
</li>
<li>
<p>常用数据的补码表示：<br>
$$<br>
[+0]_补=[-0]_补=\bold{0},00\cdots0 \<br>
[-1]_补=\bold{1},11\cdots1 \<br>
[2^n-1]_补=\bold{0},11\cdots1 \<br>
[-2^n]_补=\bold{1},00\cdots0<br>
$$</p>
</li>
<li>
<p><strong>补码与真值之间的转换</strong>：对于正数，真值与补码相同，对于负数从右往左查找第一个1的位置，将该位置左边所有的除符号位的数值位全部取反。<br>
$$<br>
[+15]_原=\bold{0},0001111 \Leftrightarrow  [+15]_补=\bold{0},0001111 \<br>
[-15]_原=\bold{1},0001111 \Leftrightarrow  [-15]_补=\bold{1},1110001 \<br>
$$</p>
</li>
</ul>
</li>
<li>
<p>反码表示法：</p>
<ul>
<li>正数的反码和原码相同，负数的反码为原码符号位不变，数值位取反。</li>
<li>若字长为n+1，则反码整数的表示范围为$-(2^n-1)\leqslant x\leqslant(2^n-1)$</li>
</ul>
</li>
<li>
<p>移码表示法：</p>
<ul>
<li>移码常用来表示浮点数的阶码，只能用来表示整数。</li>
<li>移码就是在真值X上加上一个常熟，通常取$2^n$。</li>
<li>
$[x]_补$符号位取反即得$[x]_移$。</li>
<li>移码全0时，对应真值的最小值$-2^n$，移码全1时，对应真值的最大值$2^n-1$。</li>
</ul>
</li>
<li>
<p>四种编码表示的总结：</p>
<ul>
<li>原码、补码、反码的符号位相同；</li>
<li>原码、反码的表示在数轴上对称，二者都存在+0和-0</li>
<li>补码、移码中的表示在数轴上不对称，零的表示唯一，它们比原码、反码多表示一个数。</li>
<li>整数的补码、移码的符号位相反，数值位相同。</li>
<li>复数的补码、反码末位相差1。</li>
</ul>
</li>
<li>
<p>补码的运算：</p>
<ul>
<li>
<p>加法：按位相加，符号位不需要做特殊处理。</p>
</li>
<li>
<p>减法：$[A]_补-[B]_补=[A]_补+[-B]_补$。<br>
$$<br>
[B]_补\stackrel{全部位按位取反，末位+1}{\longleftrightarrow}[-B]_补 \<br>
[19]_补=\bold{0},0010011{\leftrightarrow}[-19]_补=\bold{1},1101101<br>
$$<br>
以上操作适合计算机，手算操作：从右往左寻找第一个1的位置，从此位置往左所有位(包括符号位)都取反。</p>
</li>
</ul>
</li>
</ol>
<h3>整数的表示</h3>
<ol>
<li>
<p>当一个编码的全部二进制位均为数值位而没有符号位时，该编码表示就是无符号整数，简称无符号数。</p>
<ul>
<li>无符号整数的加法：从最低位开始，按位相加。</li>
<li>无符号整数的减法：从最低位考试，按位相减，不够向更高位借位(人算)；被减数不变，减数变为对应的补码，减法变加法(机器算)。</li>
</ul>
</li>
<li>
<p>有符号整数通常用补码表示</p>
<ul>
<li>与原码和反码相比，补码中0的表示唯一</li>
<li>与原码和移码相比，补码运算规则比较简单，且符号位可以和数值位一起参与运算</li>
<li>与原码和反码相比，补码比原码和反码多表示一个最小负数</li>
</ul>
</li>
<li>
<p>各种码的基本特性总结</p>
<table role="table">
<thead>
<tr>
<th align="center">n+1 bit</th>
<th align="center">合法表示范围</th>
<th align="center">最大的数</th>
<th align="center">最小的数</th>
<th align="center">真值0的表示</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">带符号整数：原码</td>
<td align="center">$-(2^n-1)\leqslant x\leqslant2^n-1$</td>
<td align="center">$\bold{0},11\cdots1$</td>
<td align="center">$\bold{1},11\cdots1$</td>
<td align="center">$\bold{0},00\cdots0 \\bold{1},00\cdots0$</td>
</tr>
<tr>
<td align="center">带符号整数：反码</td>
<td align="center">$-(2^n-1)\leqslant x\leqslant2^n-1$</td>
<td align="center">$\bold{0},11\cdots1$</td>
<td align="center">$\bold{1},00\cdots0$</td>
<td align="center">$\bold{0},00\cdots0\\bold{1},11\cdots1$</td>
</tr>
<tr>
<td align="center">带符号整数：补码</td>
<td align="center">$-2^n\leqslant x\leqslant2^n-1$</td>
<td align="center">$\bold{0},11\cdots1$</td>
<td align="center">$\bold{1},00\cdots0$</td>
<td align="center">$\bold{0},00\cdots0$</td>
</tr>
<tr>
<td align="center">带符号整数：移码</td>
<td align="center">$-2^n\leqslant x\leqslant2^n-1$</td>
<td align="center">$\bold{1},11\cdots1$</td>
<td align="center">$\bold{0},00\cdots0$</td>
<td align="center">$\bold{1},00\cdots0$</td>
</tr>
<tr>
<td align="center">无符号整数</td>
<td align="center">$0\leqslant x\leqslant2^{n+1}-1$</td>
<td align="center">$11\cdots1$</td>
<td align="center">$00\cdots0$</td>
<td align="center">$00\cdots0$</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>练习题</p>
<blockquote>
<p>定点整数x=50，用8位原码、反码、补码、移码表示</p>
<p>定点整数x=-100，用8位原码、反码、补码、移码表示</p>
<p>求下列各种码对应的真值：</p>
<ul>
<li>$[x]_原=\bold{1}0001101$</li>
<li>$[x]_反=\bold{1}0001101$</li>
<li>$[x]_补=\bold{1}0001101$</li>
<li>$[x]_移=\bold{1}0001101$</li>
<li>$[x]_原=\bold{0}0001101$</li>
<li>$[x]_反=\bold{0}0001101$</li>
<li>$[x]_补=\bold{0}0001101$</li>
<li>$[x]_移=\bold{0}0001101$</li>
</ul>
</blockquote>
</li>
</ol>
<h4>C语言中的整数类型及类型转换</h4>
<ol>
<li>
<markdown-accessiblity-table><table role="table">
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">位数</th>
<th align="center">默认类型</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">字符型(<code class="notranslate">char</code>)</td>
<td align="center">8</td>
<td align="center">无符号整数</td>
</tr>
<tr>
<td align="center">短整型(<code class="notranslate">short</code>)</td>
<td align="center">16</td>
<td align="center">有符号整数</td>
</tr>
<tr>
<td align="center">整形(<code class="notranslate">int</code>)</td>
<td align="center">32</td>
<td align="center">有符号整数</td>
</tr>
<tr>
<td align="center">长整型(<code class="notranslate">long</code>)</td>
<td align="center">32/64</td>
<td align="center">有符号整数</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
</li>
<li>
<p><code class="notranslate">signed/unsigned</code>整型数据都是按补码形式存储的。</p>
</li>
<li>
<p>强制类型转换的结果是保持位值不变，仅改变解释这些位的方式。</p>
</li>
<li>
<p>当大字长变量向小字长变量强制类型转换时，系统把多余的高位部分直接截断，低位部分直接赋值。</p>
</li>
<li>
<p>小字长到大字长转换时，不仅要使对应的位值相等，还要对高位部分进行扩展。</p>
</li>
</ol>
<h3>错题</h3>
<ol>
<li>
<p>设$[x]_补=1,x_1x_2x_3x_4x_5x_6$，其中$x_i$取0或1，若要$x\gt-32$，应当满足(  )<br>
A. $x_1$为0，其余各位任意</p>
<p>B. $x_1$为1，其余各位任意</p>
<p>C. $x_1$为1，$x_2\cdots x_6$中至少有一位为1</p>
<p>D. $x_1$为0，$x_2\cdots x_6$中至少有一位为1</p>
</li>
<li>
<p>设$[x]_补=1,x_1x_2x_3x_4x_5$，其中$x_i$取0或1，若要$x\lt-16$，应当满足(  )<br>
A. $x_1\cdots x_5$中至少有一位为1</p>
<p>B. $x_1$必须为0，$x_2\cdots x_5$中至少有一位为1</p>
<p>C. $x_1$必须为0，其余各位任意</p>
<p>D. $x_1$必须为1，其余各位任意</p>
</li>
<li>
<p>假定编译器规定int型和short型长度分别为32位和16位，执行下列C语言语句：</p>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-smi">unsigned short</span> <span class="pl-s1">x</span> <span class="pl-c1">=</span> <span class="pl-c1">65530</span>;
<span class="pl-smi">unsigned <span class="pl-smi">int</span></span> <span class="pl-s1">y</span> <span class="pl-c1">=</span> <span class="pl-s1">x</span>;</pre></div>
<p>得到的y的机器数为(  )</p>
<p>A. 0000 7FFAH</p>
<p>B. 0000 FFFAH</p>
<p>C. FFFF 7FFAH</p>
<p>D. FFFF FFFAH</p>
</li>
<li>
<p>考虑执行以下C语言代码：</p>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-smi">unsigned short</span> <span class="pl-s1">usi</span> <span class="pl-c1">=</span> <span class="pl-c1">65535</span>;
<span class="pl-smi">short</span> <span class="pl-s1">si</span> <span class="pl-c1">=</span> <span class="pl-s1">usi</span>;</pre></div>
<p>si的值是(  )</p>
<p>A. -1</p>
<p>B. -32767</p>
<p>C. -32768</p>
<p>D. -65535</p>
</li>
</ol>
<h2>运算方法和运算电路</h2>
<h3>基本运算部件</h3>
<ol>
<li>
<p>在计算机中，运算器由<code class="notranslate">算术逻辑单元</code>、<code class="notranslate">移位器</code>、<code class="notranslate">状态寄存器</code>和<code class="notranslate">通用寄存器</code>组成。</p>
</li>
<li>
<p>运算器的基本功能包括：加、减、乘、除四则运算，与、或、非、异或等逻辑运算，以及移位、求补等操作。</p>
<table role="table">
<thead>
<tr>
<th align="center">逻辑运算</th>
<th align="center">表达式</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">与</td>
<td align="center">$Y=A\cdot B$</td>
</tr>
<tr>
<td align="center">或</td>
<td align="center">$Y=A+B$</td>
</tr>
<tr>
<td align="center">非</td>
<td align="center">$Y=\bar{A}$</td>
</tr>
<tr>
<td align="center">与非</td>
<td align="center">$Y=\overline{A\cdot B} $</td>
</tr>
<tr>
<td align="center">或非</td>
<td align="center">$Y=\overline{A+B} $</td>
</tr>
<tr>
<td align="center">异或</td>
<td align="center">$Y=A\oplus B$</td>
</tr>
<tr>
<td align="center">同或</td>
<td align="center">$Y+A\odot B$</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>ALU的核心部件是<code class="notranslate">加法器</code>。</p>
<ul>
<li>
<p><code class="notranslate">串行加法器</code>：只有一个全加器，数据逐位串行送入加法器中进行运算。进位触发器用来寄存进位信号，以便参与下一次运算。</p>
</li>
<li>
<p><code class="notranslate">串行进位的并行加法器</code>：把n个全加器串接起来，就可进行两个n位数的相加。</p>
<p>串行进位又称行波进位，每一级进位直接依赖于前一级的进位，即进位信号是逐级形成的。</p>
</li>
<li>
<p><code class="notranslate">并行进位的并行加法器</code>：各级进位信号同时形成，又称为先行进位、同时进位。</p>
</li>
</ul>
</li>
<li>
<p>无符号数加法器只能用于两个无符号数相加，不能进行有符号整数的加减运算。为了能进行有符号正数的加减运算，还需要在无符号加法器的基础上增加相应的逻辑门电路，使得加法器不仅能计算和/差，还要能生成相应的标志信息。</p>
</li>
<li>
<p>ALU的核心是<code class="notranslate">带标志加法器</code>，同时也能执行逻辑运算。</p>
</li>
<li>
<p>A和B是两个n位操作数输入端，$C_{in}$是进位输入端，ALUop是操作控制端，用来决定ALU所执行的操作能力。</p>
</li>
</ol>
<h3>定点数的移位运算</h3>
<ol>
<li>
<p>对于任意二进制整数，左移一位，若不产生溢出，则相当于乘以2；右移一位，若不考虑因移出而舍去的末尾尾数，相当于除以2</p>
</li>
<li>
<p>根据操作数的类型不同，移位运算可以分为<code class="notranslate">逻辑移位</code>和<code class="notranslate">算术移位</code>。</p>
</li>
<li>
<p>逻辑移位：将操作数视为<code class="notranslate">无符号整数</code>。左移时，高位移出，低位补零，若高位的1移出，则发生溢出；右移时，低位移出，高位补零。</p>
</li>
<li>
<p>算数移位：将操作数视为<code class="notranslate">有符号整数</code>。左移时，高位移出，低位补零，若移出的高位不同于移位后的符号位，即左移前后的符号位不同，则发生溢出；右移时，低位移出，高位补符号位，若低位的1移出，则影响精度。</p>
<ul>
<li>原码的算术移位：符号位保持不变，仅对数值位进行移位。右移时，高位补零，低位舍弃。左移时，低位补零，高位舍弃。</li>
<li>反码的算术移位：正数的反码移位，右移时，高位补零，低位舍弃；左移时，低位补零，高位舍弃。负数的反码移位时，右移时，高位补一，低位舍弃；左移时，低位补一，高位舍弃。</li>
<li>补码的算术移位：正数的补码移位，右移时，高位补零，低位舍弃；左移时，低位补零，高位舍弃。负数的补码移位时，<code class="notranslate">右移时同反码</code>，高位补一，低位舍弃；<code class="notranslate">左移时同原码</code>，低位补零，高位舍弃。</li>
</ul>
<markdown-accessiblity-table><table role="table">
<thead>
<tr>
<th align="center">数据</th>
<th align="center">码制</th>
<th align="center">添加代码</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">正数</td>
<td align="center">原码、补码、反码</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">原码</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">负数</td>
<td align="center">补码</td>
<td align="center">左移添0</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">右移添1</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">反码</td>
<td align="center">1</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
</li>
<li>
<p>循环移位：移动时，移出的数字移动到空出的位置处。</p>
</li>
<li>
<p>带进位位的循环移位</p>
</li>
</ol>
<h3>定点数的加减运算</h3>
<ol>
<li>
<p>原码的加减法运算：</p>
<ul>
<li>加法规则：符号位相同，则数值位相加，结果符号位不变，若最高数值位相加产生进位，则发生溢出；符号位不同，则做减法，绝对值大的数减去绝对值小的数，结果符号位与绝对值大的数相同。</li>
<li>减法规则：先将减数的符号取反，然后将被减数与符号取反后的减数按原码加法进行运算。</li>
</ul>
</li>
<li>
<p>设机器字长位n+1<br>
$$<br>
[A+B]_补=[A]_补+[B]_补(mod \ 2^{n+1})\<br>
[A-B]_补=[A]_补+[-B]_补(mod \ 2^{n+1})<br>
$$<br>
补码运算的特点如下：</p>
<ul>
<li>按二进制运算规则运算，逢二进一；</li>
<li>若做加法，两个数的补码直接相加；若做减法，则将被减数与减数的负数补码相加；</li>
<li>符号位与数值位一起参与运算，加减运算结果的符号位也在运算中直接得出；</li>
<li>最终运算结果的高位丢弃，保留n+1位，运算结果也是补码。</li>
</ul>
</li>
<li>
<p>溢出判断方法：</p>
<ul>
<li>
<p>采用一位符号位：<br>
因为在运算时减法是转为加法运算，因此如果参与操作的两个数的符号相同，结果又与原操作数的符号不同，则表示结果溢出。设A的符号为$A_s$，B的符号为$B_s$，运算结果的符号为$S_s$，则溢出逻辑表达式为：<br>
$$<br>
V=A_sB_s\overline{S_s}+\overline{A_sB_s}S_s<br>
$$<br>
若V=0，表示无溢出；若V=1，表示有溢出。</p>
</li>
<li>
<p>采用双符号位(4补码)：</p>
<p>运算结果的两个符号位$S_{s1}S_{s2}$相同，表示未溢出；运算结果的两个符号位$S_{s1}S_{s2}$不相同，表示溢出，此时最高位符号位代表真正的符号。<br>
$$<br>
S_{s1}S_{s2}=\begin{cases}00&amp;\text{结果为正数，无溢出}\01&amp;\text{结果正溢出}\10&amp;\text{结果负溢出}\11&amp;\text{结果为负数，无溢出}\end{cases}<br>
$$<br>
溢出逻辑判断表达式为：<br>
$$<br>
V=S_{s1}\oplus S_{s2}<br>
$$<br>
若V=0，表示无溢出，若V=1，表示有溢出。</p>
</li>
<li>
<p>采用一位符号位根据数值位的进位情况判断溢出：<br>
若符号位的进位$C_n$与最高数位的进位$C_{n-1}$相同，说明无溢出，否则说明有溢出。<br>
溢出逻辑表达式为<br>
$$<br>
V=C_n \oplus C_{n-1}<br>
$$<br>
若V=0，表示无溢出；V=1，表示有溢出。</p>
</li>
</ul>
</li>
<li>
<p>加减法运算电路</p>
<ul>
<li>
<code class="notranslate">零标志ZF</code>：ZF=1表示结果F为0。对于无符号数和有符号数的运算，ZF都有意义。</li>
<li>
<code class="notranslate">溢出标志OF</code>：判断有符号数是否溢出，OF=1说明发生了溢出。它是符号位进位与最高数位进位的异或结果，即$OF=C_n\oplus C_{n-1}$。对于无符号数运算，OF没有意义。</li>
<li>
<code class="notranslate">符号标志SF</code>：表示结果的符号，即F的最高位，对于无符号数的运算，SF没有意义。</li>
<li>
<code class="notranslate">进/借位标志CF</code>：表示无符号数运算时的进位/借位，判断是否发生溢出。$CF=Sub\oplus C_{out}$。对于有符号整数，CF没有意义。</li>
</ul>
</li>
<li>
<p>无符号数大小的比较：</p>
<ul>
<li>对于无符号数的运算，零标志ZF、进/借位标志CF才有意义。</li>
<li>当ZF=1时，说明A=B</li>
<li>当ZF=0且CF=0时，说明A &gt; B</li>
<li>当ZF=0且CF=1时，说明A &gt; B</li>
</ul>
</li>
<li>
<p>有符号数大小的比较：</p>
<ul>
<li>对于有符号数的运算，零标志ZF、溢出标志OF、符号标志SF才有意义。</li>
<li>当ZF=1时，说明A=B</li>
<li>当ZF=0,OF$\oplus$SF=0时，说明A &gt; B</li>
<li>当ZF=0,OF$\oplus $SF=1时，说明A &gt; B</li>
</ul>
</li>
</ol>
<h3>定点数的乘除运算</h3>
<ol>
<li>
<p>原码的乘法运算</p>
<ul>
<li>
<p>原码乘法的特点：乘积的符号位由两个乘数的符号为异或得到；乘积的数值位是两个乘数的绝对值之积</p>
<ul>
<li>
<p>两个n位无符号数相乘共需进行n次加法和n次移位运算。</p>
</li>
<li>
<p>每次加法可能加零，也可能加$|x|_原$。MQ最低位为1时，加$|x|_原$；MQ最低位为0时，加零。</p>
</li>
<li>
<p>每次的移位为<code class="notranslate">逻辑移位</code>。</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>补码的乘法运算</p>
<ul>
<li>两个n位无符号数相乘工序进行n次加法和n次移位运算，最后再多算一次加法</li>
<li>每次加法可能加零，可能加$x_补$，也可能加$-x_补$</li>
<li>辅助位-MQ中最低位为1时，加$x_补$；辅助位-MQ中最低位为0时加零；辅助位-MQ中最低位为-1时加$-x_补$</li>
<li>每次的移位为<code class="notranslate">算术移位</code>
</li>
<li>补码的符号位需要参与运算</li>
</ul>
</li>
<li>
<p>原码与补码乘法运算的比较</p>
<table role="table">
<thead>
<tr>
<th align="center">码制</th>
<th align="center">操作次数</th>
<th align="center">加数</th>
<th align="center">移位类型</th>
<th align="center">符号位</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">原码</td>
<td align="center">n轮加法，n次移位</td>
<td align="center">0、$|x|_原$</td>
<td align="center">逻辑移位</td>
<td align="center">不参与运算</td>
</tr>
<tr>
<td align="center">补码</td>
<td align="center">n+1轮加法，n次移位，</td>
<td align="center">0、$[x]_补$、$[-x]_补$</td>
<td align="center">算数移位</td>
<td align="center">参与运算</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>原码的除法运算</p>
<ul>
<li>恢复余数法</li>
<li>加减交替法</li>
</ul>
</li>
<li>
<p>补码的除法运算</p>
<ul>
<li>符号位参与运算</li>
<li>被除数、除数与余数均采用<code class="notranslate">双符号位</code>
</li>
<li>被除数和除数同号，则被除数减去除数，异号则被除数加上除数。</li>
<li>余数和除数同号，商1，余数左移一位减去除数；余数和除数异号，商0，余数左移一位加上除数。</li>
<li>最后一位恒置为1，精度不超过$2^{-n}$且比较省事。</li>
</ul>
</li>
<li>
<p>原码与补码除法的比较</p>
<table role="table">
<thead>
<tr>
<th align="center">除法类型</th>
<th align="center">符号位</th>
<th align="center">加减次数</th>
<th align="center">移位</th>
<th align="center">上商、加减原则</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">原码加减交替法</td>
<td align="center">不参与运算</td>
<td align="center">n+1或N+2</td>
<td align="center">向左移动N次</td>
<td align="center">余数的正负</td>
<td align="center">若最终余数为负，需恢复余数</td>
</tr>
<tr>
<td align="center">补码加减交替法</td>
<td align="center">参与运算</td>
<td align="center">n+1</td>
<td align="center">向左移动N次</td>
<td align="center">余数和除数是否同号</td>
<td align="center">商末位恒置为1</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>n位定点数的除法运算，需要统一为：一个2n位的数除以一个n位的数，得到一个n位的商，因此需要对除数进行扩展。</p>
</li>
<li>
<p>若是2n位除以n位的无符号数，商的位数为n+1位，当第一次试商为1时，则表示结果溢出。若是两个n位的无符号数相除，则第一位商为0，且结果肯定不会溢出。</p>
<ul>
<li>若是两个32位int型整数相除，则除了$-2^{31}/-1$会溢出，其余情况都不会溢出。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3>错题</h3>
<ol>
<li>
<p>关于模4补码，下列说法正确的是(  )</p>
<p>A. 模4补码和模2补码不同，它更容易检查乘除运算中的溢出问题</p>
<p>B. 每个模4补码存储时只需要一个符号位</p>
<p>C. 存储每个模4补码需要两个符号位</p>
<p>D. 模4补码，在算数与逻辑单元中为一个符号位</p>
</li>
<li>
<p>某计算机字长为8位，CPU中有一个8位加法器。已知无符号数x=69，y=38，若在该加法器中计算x-y，则加法器的两个输入端信息和输入的低位进位信息分别为(  )</p>
<p>A. 0100 0101、0010 0110、0</p>
<p>B. 0100 0101、1101 1001、1</p>
<p>C. 0100 0101、1101 1010、0</p>
<p>D. 0100 0101、1101 1010、1</p>
</li>
<li>
<p>某计算机中有一个8位加法器，有符号整数x和y的机器数用补码表示，$[x]_补$=F5H，$[y]_补$=7EH，若在该加法器中计算x-y，则加法器的低位进位输入信息和运算后的溢出标志OF分别为(  )</p>
<p>A. 1、1</p>
<p>B. 1、0<br>
C. 0、1</p>
<p>D. 0、0</p>
</li>
</ol>
<h2>浮点数的表示与运算</h2>
<h3>浮点数的表示</h3>
<ol>
<li>
<p>浮点数由<code class="notranslate">符号</code>、<code class="notranslate">尾数</code>和<code class="notranslate">阶码</code>三部分组成，表示格式为：<br>
$$<br>
N=(-1)^s\times M\times R^E<br>
$$<br>
S取值0或1，用于表示浮点数的符号，M是一个二进制定点小数，称为尾数，一般用<code class="notranslate">定点源码小数</code>表示；E是一个二进制定点整数，称为阶码或指数，用<code class="notranslate">移码</code>表示；R是基数。</p>
</li>
<li>
<p>浮点数的表示范围：</p>
<p>负下溢正下溢可表示的正数可表示的负数负上溢正上溢−1−2−24×263−2−24×2−642−24×2−641−2−24×263</p>
<p>运算结果大于最大正数称为正上溢，小于最小负数称为负上溢。</p>
<p>当运算结果在1至最小正数之间时称为正下溢，在最大负数至0之间时称为负下溢。</p>
</li>
<li>
<p>浮点数的规格化：</p>
<ul>
<li>左规：当运算结果的尾数的最高位不是有效位，需要进行左规。左规时，尾数每左移一位，阶码减一。</li>
<li>右规：当运算结果的尾数的有效位进到小数点前面时，需要进行右规，右规只需进行一次。将尾数右移一次，阶码加一。右规时，阶码增加可能导致溢出。</li>
</ul>
</li>
<li>
<p>IEEE 754标准</p>
<ul>
<li>
<p>浮点数格式有32位单精度浮点数和64位双精度浮点数</p>
<table role="table">
<thead>
<tr>
<th align="center">类型</th>
<th align="center">符号s</th>
<th align="center">阶码e</th>
<th align="center">尾数f</th>
<th align="center">总位数</th>
<th align="center">偏置值</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">单精度</td>
<td align="center">1</td>
<td align="center">8</td>
<td align="center">23</td>
<td align="center">32</td>
<td align="center">7FH 127</td>
</tr>
<tr>
<td align="center">双精度</td>
<td align="center">1</td>
<td align="center">11</td>
<td align="center">52</td>
<td align="center">64</td>
<td align="center">3FFH 1023</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>对于规格化的二进制浮点数，尾数的最高位总是1，为了能使位数多表示以为有效位，将这个1隐藏，称为<code class="notranslate">隐藏位</code>。</p>
</li>
<li>
<p>在IEEE 754标准中，指数用移码表示，偏置值为$2^{n-1}+1$。<br>
规格化单精度浮点数的真值为：$(-1)^s\times 1.f \times 2^{e-127}$<br>
规格化双精度浮点数的真值为：$(-1)^s\times 1.f \times 2^{e-1023}$</p>
</li>
<li>
<p>IEEE 754标准中阶码全零或全一时的特殊意义</p>
<table role="table">
<thead>
<tr>
<th align="center">符号</th>
<th align="center">阶码</th>
<th align="center">尾数</th>
<th align="center">特殊意义</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">0/1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0/1</td>
<td align="center">255</td>
<td align="center">0</td>
<td align="center">$ \pm\infty$</td>
</tr>
<tr>
<td align="center">0/1</td>
<td align="center">255</td>
<td align="center">f$\neq$0</td>
<td align="center">NaN</td>
</tr>
<tr>
<td align="center">0/1</td>
<td align="center">0</td>
<td align="center">f$\neq$0</td>
<td align="center">$\pm (0.f\times2^{-126}/0.f\times2^{-1022})$</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ol>
<h3>浮点数的加减运算</h3>
<ol>
<li>
<p>浮点数的加减运算主要分为以下几步：</p>
<ul>
<li>
<p>对阶：<br>
小阶码向大阶码对齐。尾数右移时，低位移出的位不要丢掉，应保留并参加尾数部分的运算。</p>
</li>
<li>
<p>尾数加减：<br>
按定点原码小数的加减运算规则进行运算。加减时必须将隐藏位还原到位数部分。</p>
</li>
<li>
<p>尾数规格化</p>
</li>
<li>
<p>舍入：<br>
就近舍入：舍入为最近的可表示数；<br>
正向舍入：取右边最近的可表示数；</p>
<p>负向舍入：取左边最近的可表示数；</p>
<p>截断法：直接截取所需要的位数。</p>
</li>
<li>
<p>溢出判断：<br>
若一个正指数超过了最大允许值(127或1023)，则发生<code class="notranslate">指数上溢</code>，产生异常；若一个负指数超过了最小允许值(-149或-1074)，则发生<code class="notranslate">指数下溢</code>，按机器零处理。</p>
</li>
</ul>
</li>
</ol>
<h3>C语言中的浮点数类型</h3>
<ol>
<li>
<p>不同类型数混合运算时，遵循的规则是“类型提升”，即较低类型转换为较高类型。</p>
</li>
<li>
<p>数据转换分析：</p>
<markdown-accessiblity-table><table role="table">
<thead>
<tr>
<th align="center">原始类型</th>
<th align="center">目标类型</th>
<th align="center">精度</th>
<th align="center">溢出</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">int</td>
<td align="center">float</td>
<td align="center">可能影响</td>
<td align="center">不会溢出</td>
</tr>
<tr>
<td align="center">int/float</td>
<td align="center">double</td>
<td align="center">不会影响</td>
<td align="center">不会溢出</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">float</td>
<td align="center">可能影响</td>
<td align="center">可能溢出</td>
</tr>
<tr>
<td align="center">float/double</td>
<td align="center">int</td>
<td align="center">可能影响</td>
<td align="center">可能溢出</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
</li>
</ol>
<h3>数据的大小端和对齐存储</h3>
<ol>
<li>数据存储时，数据从低位到高位可以按从左到右排列，也可按从右到左排列。因此无法用最左或最有表示数据的高位和低位。通常用最低有效字节(LSB)和最高有效字节(MSB)来分别表示数据的低位和高位。</li>
<li>数据排列方式：<code class="notranslate">大端存储</code>、<code class="notranslate">小端存储</code>
<ul>
<li>大端存储：先存储高位字节，后存储低位字节。字中的字节顺序和原序列的相同。</li>
<li>小端存储：先存储低位字节，后存储高位字节。字中的字节顺序和原序列的相反。</li>
</ul>
</li>
<li><code class="notranslate">边界对齐方式</code>：存放地址是自身大小的整数倍，半字地址一定是2的整数倍，字地址一定是4的整数倍。当所存数据不满足上述要求时，可通过填充空白字节使其符合要求。</li>
</ol>
<h3>错题</h3>
<ol>
<li>
<p>在规格化浮点运算中，若某浮点数为$2^5\times1.10101$，其中尾数为补码表示，则该数(  )<br>
A. 不需要规格化<br>
B. 需要右移规格化<br>
C. 需要将尾数左移一位规格化<br>
D. 需要将尾数左移两位规格化</p>
</li>
<li>
<p>采用规格化浮点数最主要的目的是(  )<br>
A. 增加数据的表示范围<br>
B. 方便浮点运算<br>
C. 防止运算时数据溢出<br>
D. 增加数据的表示精度</p>
</li>
<li>
<p>在规格化的浮点数中，将阶码部分用移码表示改为补码表示，其他不变，则浮点数的表示范围(  )<br>
A. 增大<br>
B. 减小<br>
C. 不变<br>
D. 都不对</p>
</li>
<li>
<p>假定变量i、f的数据类型分别是int、float。已知i=12345，f=1.2345$\times2^3$，则在一个32位机器中执行下列表达式时，结果为“假”的是(  )<br>
A. i=(int)(double)i<br>
B. f=(float)(double)f<br>
C. i=(int)(float)i<br>
D. f=(float)(int)f</p>
</li>
<li>
<p>设浮点数的阶码和尾数均采用补码表示，且位数分别为5和7(均含2位符号位)。若有两个数X=$2^7\times29/32$和Y=$2^5\times5/8$，则用浮点加法计算X+Y的最终结果是(  )</p>
<p>A. 00111 1100010</p>
<p>B. 00111 0100010</p>
<p>C. 01000 0010001</p>
<p>D. 发生溢出</p>
</li>
<li>
<p>假定变量i、f和D的数据类型分别为int、float和double(int型用补码表示，float型和double型分别用IEEE 754单精度和双精度浮点数格式表示)，已知i=785、f=1.5678E3、d=1.5E100，若在32位机器中执行下列关系表达式，则结果为“真”的是(  )<br>
I. i=(int)(float)i</p>
<p>II. f=(float)(int)f</p>
<p>III.f=(float)(double)f</p>
<p>IV.(d+f)-d=f</p>
<p>A. 仅I和II</p>
<p>B. 仅I和III</p>
<p>C. 仅II和III</p>
<p>D. 仅III和IV</p>
</li>
<li>
<p>某32位计算机按字节编址，采用小端方式。若语句int  i = 0，对应指令的机器代码为“C7 45 FC 00 00 00 00”，则语句int i = -64对应指令的机器代码是(  )<br>
A. C7 45 FC C0 FF FF FF<br>
B. C7 45 FC 0C FF FF FF<br>
C. C7 45 FC FF FF FF C0<br>
D. C7 45 FC FF FF FF 0C</p>
</li>
<li>
<p>-0.4375的IEEE 754单精度浮点数表示为(  )</p>
<p>A. BEE0 0000H</p>
<p>B. BF60 0000H</p>
<p>C. BF70 0000H</p>
<p>D. C0E0 0000H</p>
</li>
</ol></div>
<div style="font-size:small;margin-top:8px;float:right;"></div>

<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>

</div>
    <div id="footer"><div id="footer1">Copyright © <span id="copyrightYear"></span> <a href="https://wlkla.github.io/onebuaaer.github.io">我在人世间踽踽独行</a></div>
<div id="footer2">
    <span id="runday"></span><span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a></span>
</div>

<script>
var now=new Date();
document.getElementById("copyrightYear").innerHTML=now.getFullYear();

if("09/02/2024"!=""){
    var startSite=new Date("09/02/2024");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";
}
</script></div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z', 'copy': 'M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z', 'check': 'M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);



function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","wlkla/onebuaaer.github.io");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const createClipboardHTML = (codeContent, additionalClasses = '') => `
        <pre class="notranslate"><code class="notranslate">${codeContent}</code></pre>
        <div class="clipboard-container position-absolute right-0 top-0 ${additionalClasses}">
            <clipboard-copy class="ClipboardButton btn m-2 p-0" role="button" style="display: inherit;">
                <svg height="16" width="16" class="octicon octicon-copy m-2"><path d="${IconList["copy"]}"></path></svg>
                <svg height="16" width="16" class="octicon octicon-check color-fg-success m-2 d-none"><path d="${IconList["check"]}"></path></svg>
            </clipboard-copy>
            <div class="copy-feedback">Copied!</div>
        </div>
    `;

    const handleCodeElements = (selector = '') => {
        document.querySelectorAll(selector).forEach(codeElement => {
            const codeContent = codeElement.innerHTML;
            const newStructure = document.createElement('div');
            newStructure.className = 'snippet-clipboard-content position-relative overflow-auto';
            newStructure.innerHTML = createClipboardHTML(codeContent);

            const parentElement = codeElement.parentElement;
            if (selector.includes('highlight')) {
                parentElement.insertBefore(newStructure, codeElement.nextSibling);
                parentElement.removeChild(codeElement);
            } else {
                parentElement.parentElement.replaceChild(newStructure, parentElement);
            }
        });
    };

    handleCodeElements('pre.notranslate > code.notranslate');
    handleCodeElements('div.highlight > pre.notranslate');

    let currentFeedback = null;
    document.querySelectorAll('clipboard-copy').forEach(copyButton => {
        copyButton.addEventListener('click', () => {
            const codeContent = copyButton.closest('.snippet-clipboard-content').innerText;
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = codeContent;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            document.execCommand('copy');
            document.body.removeChild(tempTextArea);

            const copyIcon = copyButton.querySelector('.octicon-copy');
            const checkIcon = copyButton.querySelector('.octicon-check');
            const copyFeedback = copyButton.nextElementSibling;

            if (currentFeedback && currentFeedback !== copyFeedback) {currentFeedback.style.display = 'none';}
            currentFeedback = copyFeedback;

            copyIcon.classList.add('d-none');
            checkIcon.classList.remove('d-none');
            copyFeedback.style.display = 'block';
            copyButton.style.borderColor = 'var(--color-success-fg)';

            setTimeout(() => {
                copyIcon.classList.remove('d-none');
                checkIcon.classList.add('d-none');
                copyFeedback.style.display = 'none';
                copyButton.style.borderColor = '';
            }, 2000);
        });
    });
});

</script>
<script src='https://onebuaaer.us.kg/assets/backtotop.js'></script><script src='https://onebuaaer.us.kg/assets/lazyload.js'></script><script>MathJax = {tex: {inlineMath: [["$", "$"]]}};</script><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

</html>
