<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    <script src='https://onebuaaer.us.kg/assets/theme.js'>
    <link rel="icon" href="https://telegraph-image-6b4.pages.dev/file/3a89e862ad5a60a260608.jpg"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="# 内存管理

## 内存管理概念

### 内存管理的基本原理和要求

1. 内存管理的主要功能

   ```mermaid
   graph TB
   	A(内存管理)-->B(内存空间的分配和回收)
   	A-->C(地址转换)
   	A-->D(内存空间的扩充)
   	A-->E(内存共享)
   	A-->F(存储保护)
   ```

2. 程序的链接与装入

   - 创建进程首先要将程序和数据装入内存，通常有以下步骤

     ```mermaid
     graph LR
     	A(用户源代码)-->|编译|B(目标模块)-->|链接|C(装入模块)-->|装入|D(运行)
     ```

     编译：由**编译程序**将用户源代码编译成若干目标模块

     链接：由**链接程序**将编译后形成的一组目标模块，以及它们所需的库函数链接在一起，形成一个完成的装入模块

     装入：由**装入程序**将装入模块装入内存运行

3. 将一个装入模块装入内存有三种装入方式：

     ```mermaid
     graph LR
     	A(装入方式)-->B(绝对装入)
     	A-->C(可重定位装入/静态重定位)
     	A-->D(动态运行时装入/动态重定位)
     ```

     - 绝对装入：只适用于单道程序环境。">
<meta property="og:title" content="内存管理">
<meta property="og:description" content="# 内存管理

## 内存管理概念

### 内存管理的基本原理和要求

1. 内存管理的主要功能

   ```mermaid
   graph TB
   	A(内存管理)-->B(内存空间的分配和回收)
   	A-->C(地址转换)
   	A-->D(内存空间的扩充)
   	A-->E(内存共享)
   	A-->F(存储保护)
   ```

2. 程序的链接与装入

   - 创建进程首先要将程序和数据装入内存，通常有以下步骤

     ```mermaid
     graph LR
     	A(用户源代码)-->|编译|B(目标模块)-->|链接|C(装入模块)-->|装入|D(运行)
     ```

     编译：由**编译程序**将用户源代码编译成若干目标模块

     链接：由**链接程序**将编译后形成的一组目标模块，以及它们所需的库函数链接在一起，形成一个完成的装入模块

     装入：由**装入程序**将装入模块装入内存运行

3. 将一个装入模块装入内存有三种装入方式：

     ```mermaid
     graph LR
     	A(装入方式)-->B(绝对装入)
     	A-->C(可重定位装入/静态重定位)
     	A-->D(动态运行时装入/动态重定位)
     ```

     - 绝对装入：只适用于单道程序环境。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://wlkla.github.io/onebuaaer.github.io/post/nei-cun-guan-li.html">
<meta property="og:image" content="https://telegraph-image-6b4.pages.dev/file/3a89e862ad5a60a260608.jpg">
<title>内存管理</title>
<link href="//unpkg.com/@wooorm/starry-night@2.1.1/style/both.css" rel="stylesheet" />


</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
.copy-feedback {
    display: none;
    position: absolute;
    top: 10px;
    right: 50px;
    color: var(--color-fg-on-emphasis);
    background-color: var(--color-fg-muted);
    border-radius: 3px;
    padding: 5px 8px;
    font-size: 12px;
}
</style>




<body>
    <div id="header">
<h1 class="postTitle">内存管理</h1>
<div class="title-right">
    <a href="https://wlkla.github.io/onebuaaer.github.io" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/wlkla/onebuaaer.github.io/issues/4" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><h1>内存管理</h1>
<h2>内存管理概念</h2>
<h3>内存管理的基本原理和要求</h3>
<ol>
<li>
<p>内存管理的主要功能</p>
<div class="highlight highlight-source-mermaid"><pre class="notranslate"><span class="pl-k">graph</span> <span class="pl-c1">TB</span>
	<span class="pl-ent">A</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>内存管理<span class="pl-pds"><span class="pl-sg">)</span></span></span><span class="pl-k">--&gt;</span><span class="pl-ent">B</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>内存空间的分配和回收<span class="pl-pds"><span class="pl-sg">)</span></span></span>
	<span class="pl-ent">A</span><span class="pl-k">--&gt;</span><span class="pl-ent">C</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>地址转换<span class="pl-pds"><span class="pl-sg">)</span></span></span>
	<span class="pl-ent">A</span><span class="pl-k">--&gt;</span><span class="pl-ent">D</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>内存空间的扩充<span class="pl-pds"><span class="pl-sg">)</span></span></span>
	<span class="pl-ent">A</span><span class="pl-k">--&gt;</span><span class="pl-ent">E</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>内存共享<span class="pl-pds"><span class="pl-sg">)</span></span></span>
	<span class="pl-ent">A</span><span class="pl-k">--&gt;</span><span class="pl-ent">F</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>存储保护<span class="pl-pds"><span class="pl-sg">)</span></span></span></pre></div>
</li>
<li>
<p>程序的链接与装入</p>
<ul>
<li>
<p>创建进程首先要将程序和数据装入内存，通常有以下步骤</p>
<div class="highlight highlight-source-mermaid"><pre class="notranslate"><span class="pl-k">graph</span> <span class="pl-c1">LR</span>
	<span class="pl-ent">A</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>用户源代码<span class="pl-pds"><span class="pl-sg">)</span></span></span><span class="pl-k">--&gt;</span><span class="pl-k">|</span><span class="pl-s">编译</span><span class="pl-k">|</span><span class="pl-ent">B</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>目标模块<span class="pl-pds"><span class="pl-sg">)</span></span></span><span class="pl-k">--&gt;</span><span class="pl-k">|</span><span class="pl-s">链接</span><span class="pl-k">|</span><span class="pl-ent">C</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>装入模块<span class="pl-pds"><span class="pl-sg">)</span></span></span><span class="pl-k">--&gt;</span><span class="pl-k">|</span><span class="pl-s">装入</span><span class="pl-k">|</span><span class="pl-ent">D</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>运行<span class="pl-pds"><span class="pl-sg">)</span></span></span></pre></div>
<p>编译：由<strong>编译程序</strong>将用户源代码编译成若干目标模块</p>
<p>链接：由<strong>链接程序</strong>将编译后形成的一组目标模块，以及它们所需的库函数链接在一起，形成一个完成的装入模块</p>
<p>装入：由<strong>装入程序</strong>将装入模块装入内存运行</p>
</li>
</ul>
</li>
<li>
<p>将一个装入模块装入内存有三种装入方式：</p>
<div class="highlight highlight-source-mermaid"><pre class="notranslate"><span class="pl-k">graph</span> <span class="pl-c1">LR</span>
	<span class="pl-ent">A</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>装入方式<span class="pl-pds"><span class="pl-sg">)</span></span></span><span class="pl-k">--&gt;</span><span class="pl-ent">B</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>绝对装入<span class="pl-pds"><span class="pl-sg">)</span></span></span>
	<span class="pl-ent">A</span><span class="pl-k">--&gt;</span><span class="pl-ent">C</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>可重定位装入/静态重定位<span class="pl-pds"><span class="pl-sg">)</span></span></span>
	<span class="pl-ent">A</span><span class="pl-k">--&gt;</span><span class="pl-ent">D</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>动态运行时装入/动态重定位<span class="pl-pds"><span class="pl-sg">)</span></span></span></pre></div>
<ul>
<li>绝对装入：只适用于单道程序环境。在编译时，编译程序直接产生绝对地址的目标代码，装入程序按照装入模块的地址，将程序和数据装入内存，不需要对程序和数据的地址进行修改</li>
<li>可重定位装入：经过编译、链接的装入模块的起始地址从0开始，装入时根据内存的当前情况将装入模块装入内存的适当位置，同时对目标程序中的相对地址的修改过程称为重定位/地址转换</li>
<li>动态运行时装入：装入程序将装入模块装入内存后，只有在程序执行时才将装入模块中的相对地址转换为绝对地址。因此装入内存后的所有地址均为相对地址，需要一个重定位寄存器的支持</li>
</ul>
</li>
<li>
<p>对目标模块进行链接时，链接方式分类：</p>
<div class="highlight highlight-source-mermaid"><pre class="notranslate"><span class="pl-k">graph</span> <span class="pl-c1">TB</span>
	<span class="pl-ent">A</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>模块链接方式<span class="pl-pds"><span class="pl-sg">)</span></span></span><span class="pl-k">--&gt;</span><span class="pl-ent">B</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>静态链接<span class="pl-pds"><span class="pl-sg">)</span></span></span>
	<span class="pl-ent">A</span><span class="pl-k">--&gt;</span><span class="pl-ent">C</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>装入时动态链接<span class="pl-pds"><span class="pl-sg">)</span></span></span>
	<span class="pl-ent">A</span><span class="pl-k">--&gt;</span><span class="pl-ent">D</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>运行时动态链接<span class="pl-pds"><span class="pl-sg">)</span></span></span></pre></div>
<ul>
<li>静态链接：在程序运行前，先将各目标模块及它们所需要的库函数链接成一个完整的装入模块，以后不再拆开<br>
将几个目标模块装配成一个装入模块时，需要解决的问题：修改相对地址；变换外部调用符号</li>
<li>装入时动态链接：将用户源程序编译后所得到的一组目标模块装入内存时采用边装入边链接的方式<br>
优点：便于修改和更新，便于实现对目标模块的共享</li>
<li>运行时动态链接：在程序执行中需要某目标模块时，才对它进行链接。凡是程序执行中未用到的目标模块都不会被调入内存和链接到装入模块上<br>
优点：能加快程序的装入过程，还可节省内存空间</li>
</ul>
</li>
<li>
<p>编译后，每个目标模块都从0号单元开始编址，称为该目标模块的相对地址/逻辑地址。当链接程序将各个模块链接成一个完整的可执行目标程序时，链接程序顺序依次按各个模块的相对地址构成统一的从0号单元开始编制的逻辑地址空间/虚拟地址空间</p>
</li>
<li>
<p>物理地址空间是指内存中物理单元的集合，进程在运行时执行指令和访问数据，都要通过物理地址从主存中存取。将可执行代码装入内存时，必须通过地址转换将逻辑地址转换为物理地址，这个过程称为<strong>地址重定位</strong></p>
</li>
<li>
<p>操作系统通过**内存管理部件(MMU)**将进程使用的逻辑地址转换为物理地址</p>
</li>
<li>
<p>一个进程的内存映像组成：</p>
<div class="highlight highlight-source-mermaid"><pre class="notranslate"><span class="pl-k">graph</span> <span class="pl-c1">LR</span>
	<span class="pl-ent">A</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>内存映像<span class="pl-pds"><span class="pl-sg">)</span></span></span><span class="pl-k">--&gt;</span><span class="pl-ent">B</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>代码段<span class="pl-pds"><span class="pl-sg">)</span></span></span><span class="pl-k">--&gt;</span><span class="pl-ent">G</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>二进制代码，可以被共享<span class="pl-pds"><span class="pl-sg">)</span></span></span>
	<span class="pl-ent">A</span><span class="pl-k">--&gt;</span><span class="pl-ent">C</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>数据段<span class="pl-pds"><span class="pl-sg">)</span></span></span><span class="pl-k">--&gt;</span><span class="pl-ent">H</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>程序运行时处理的对象<span class="pl-pds"><span class="pl-sg">)</span></span></span>
	<span class="pl-ent">A</span><span class="pl-k">--&gt;</span><span class="pl-ent">D</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>PCB<span class="pl-pds"><span class="pl-sg">)</span></span></span><span class="pl-k">--&gt;</span><span class="pl-ent">I</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>用来实现进程管理<span class="pl-pds"><span class="pl-sg">)</span></span></span>
	<span class="pl-ent">A</span><span class="pl-k">--&gt;</span><span class="pl-ent">E</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>堆<span class="pl-pds"><span class="pl-sg">)</span></span></span><span class="pl-k">--&gt;</span><span class="pl-ent">J</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>用来存放动态分配的变量<span class="pl-pds"><span class="pl-sg">)</span></span></span>
	<span class="pl-ent">A</span><span class="pl-k">--&gt;</span><span class="pl-ent">F</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>栈<span class="pl-pds"><span class="pl-sg">)</span></span></span><span class="pl-k">--&gt;</span><span class="pl-ent">K</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>用来实现函数调用<span class="pl-pds"><span class="pl-sg">)</span></span></span></pre></div>
</li>
<li>
<p>内存保护：确保每个进程都有一个单独的内存空间</p>
</li>
<li>
<p>内存保护的方法：</p>
<ul>
<li>
<p>在CPU中设置一对上、下限寄存器，存放用户进程在主存中的上限地址和下限地址，每当CPU要访问一个地址时，判断是否越界</p>
</li>
<li>
<p>采用重定位寄存器(基地址寄存器)和界地址寄存器(限长寄存器)进行越界检查。重定位寄存器存放进程的起始物理地址，界地址寄存器存放进程的最大逻辑地址</p>
<p>加载重定位寄存器和界地址寄存器时必须使用特权指令，只有操作系统内核才可以加载这两个寄存器</p>
</li>
</ul>
</li>
<li>
<p>可重入代码/纯代码：一种允许多个进程同时访问但不允许被任何进程修改的代码。可以为每个进程配备局部数据区，将在执行中可能改变的部分复制到该数据区，这样程序在执行时就只需要对私有数据区中的内存进行修改，不去改变共享的代码</p>
</li>
</ol>
<h3>连续分配管理方式</h3>
<ol>
<li>
<p>连续分配方式是指为一个用户程序分配为一个连续的内存空间</p>
<div class="highlight highlight-source-mermaid"><pre class="notranslate"><span class="pl-k">graph</span> <span class="pl-c1">TB</span>
	<span class="pl-ent">A</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>连续分配方式<span class="pl-pds"><span class="pl-sg">)</span></span></span><span class="pl-k">--&gt;</span><span class="pl-ent">B</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>单一连续分配<span class="pl-pds"><span class="pl-sg">)</span></span></span>
	<span class="pl-ent">A</span><span class="pl-k">--&gt;</span><span class="pl-ent">C</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>固定分区分配<span class="pl-pds"><span class="pl-sg">)</span></span></span>
	<span class="pl-ent">A</span><span class="pl-k">--&gt;</span><span class="pl-ent">D</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>动态分区分配<span class="pl-pds"><span class="pl-sg">)</span></span></span></pre></div>
</li>
<li>
<p>单一连续分配</p>
<ul>
<li>内存被分为系统区和用户区</li>
<li>系统区仅供操作系统使用，通常在低地址部分</li>
<li>用户区仅有一道用户程序</li>
<li>优点：简单、无外部碎片；不需要内存保护</li>
<li>缺点：只能用于单用户、单任务的操作系统中；有内部碎片；存储器的利用率极低</li>
</ul>
</li>
<li>
<p>固定分区分配</p>
<ul>
<li>
<p>将用户内存空间划分为若干固定大小的分区，每个分区只装入一道作业。当有空闲分区时，便可再从外存的后备作业队列中选择适当大小的作业装入该分区</p>
</li>
<li>
<p>划分分区的方法：</p>
<ul>
<li>分区大小相等</li>
<li>分区大小不等</li>
</ul>
</li>
<li>
<p>为了便于分配和回收，建立一张分区使用表，通常按分区大小排列，各表项包括对应分区的起始地址，大小和状态</p>
<table role="table">
<thead>
<tr>
<th align="center">分区号</th>
<th align="center">大小</th>
<th align="center">始址</th>
<th align="center">状态</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">1</td>
<td align="center">12</td>
<td align="center">20</td>
<td align="center">已分配</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">32</td>
<td align="center">32</td>
<td align="center">未分配</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">64</td>
<td align="center">64</td>
<td align="center">未分配</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>存在的问题：</p>
<ul>
<li>程序太大放不到任何一个分区</li>
<li>程序太小，造成空间浪费，产生内部碎片，空间利用率低</li>
</ul>
</li>
</ul>
</li>
<li>
<p>动态分区分配</p>
<ul>
<li>
<p>指进程装入内存时，根据进程的实际需要，动态分配内存，并使分区的大小正好适合进程的需要</p>
</li>
<li>
<p>随着时间的推移，内存中会产生越来越多的外部碎片，导致内存的利用率随之下降</p>
</li>
<li>
<p>在动态分区分配中，设置一张空闲分区表。分配内存时，检索空闲分区表；回收内存时会出现以下四种情况：</p>
<ul>
<li>回收区与前一空闲分区相邻，将两个分区合并并修改前一分区表项</li>
<li>回收区与后一空闲分区相邻，将两个分区合并并修改后一分区表项</li>
<li>回收区与前后空闲分区均相邻，将三个分区合并并修改前一分区表项，删除后一分区表项</li>
<li>回收区前后分区均不空闲，则在回收区新建一个表项并插入空闲分区表</li>
</ul>
</li>
<li>
<p>按照从空闲分区表中选出分区的方法不同，将分区检索方法分为：<strong>顺序分配算法</strong>和<strong>索引分配算法</strong></p>
</li>
<li>
<p>顺序分配算法</p>
<ul>
<li>
<p>首次适应算法(First Fit)：空闲分区按地址递增的次序排列。每次分配内存时，顺序查找第一个能满足大小的空闲空间。</p>
<p>缺点：使内存低地址部分出现许多小碎片，每次分配查找时都要经过这些分区，增加了开销</p>
</li>
<li>
<p>临近适应算法(Next Fit)：类似首次适应算法，分配内存时从上次查找结束的位置开始查找。<br>
特点：让内存低、高地址部分的空闲空间以同等概率被分配，划分为小分区，导致内存高地址部分没有大空闲分区可用</p>
</li>
<li>
<p>最佳适应算法(Best Fit)：空闲分区安荣零递增的次序排列。每次分配内存时，顺序查找第一个能满足大小的空闲空间。</p>
<p>缺点：会产生很多外部碎片</p>
</li>
<li>
<p>最坏适应算法(Worst Fit)：空闲分区按容量递减的次序排列。每次分配内存时，顺序查找第一个能满足要求的空闲空间。</p>
<p>缺点：会很快导致没有大空闲分区可用</p>
</li>
</ul>
</li>
<li>
<p>索引分配算法</p>
<ul>
<li>
<p>快速适应算法：首先根据进程的长度，在索引表中找到能容纳它的最小空闲分区链表，然后从链表中取出第一块进行分配</p>
<p>优点：查找效率高，不产生内部碎片</p>
<p>缺点：回收分区时，要有效地合并分区，算法比较复杂，系统开销较大</p>
</li>
<li>
<p>伙伴系统：规定所有分区的大小均为$2^k$(k为整数)。当需要为进程分配大小为n的分区时($2^{i-1}\lt n\leqslant 2^i$)，在大小为$2^i$的空闲分区链中查找。若找到，则分配给进程，若找不到，在大小为$2^{i+1}$的空闲分区中查找。若存在大小为$2^{i+1}$的分区，则将其分为两个分区，整两个分区称为一堆伙伴，其中一个用于分配，而将两一个加入大小为$2^i$的空闲分区表。若不存在，则继续查找，直到找到为止。回收时，也可能需要对伙伴分区进行合并</p>
</li>
<li>
<p>哈希算法：根据空闲分区链表的分布规律，建立哈希函数，构建一张以空闲分区大小为关键字的哈希表，每个表项记录一个对应空闲分区表的头指针。分配时，根据所需分区大小，通过哈希函数计算得到哈希表中的位置，从中得到相应的空闲分区链表</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3>基本分页存储管理</h3>
<ol>
<li>
<p>将内存空间分为若干固定大小的分区，称为页框、页帧或物理块。进程的逻辑地址空间也分为与块大小相等的若干区域，称为页或页面</p>
</li>
<li>
<p>操作系统以页框为单位为各个进程分配内存空间</p>
</li>
<li>
<p>进程的逻辑地址空间中的每个页面有一个编号，称为页号，从0开始；内存空间中的每个页框也有一个编号，称为页框号/物理块号，也从0开始</p>
</li>
<li>
<p>页面太小会使进程的页面数过多，这样页表就会过长，占用大量内存，也会增加硬件地址转换的开销，降低页面换入/换出的效率；页面过大又会使页内碎片增多，降低内存的利用率</p>
</li>
<li>
<p>分页存储管理的逻辑地址结构：前一部分为<strong>页号P</strong>，后一部分为<strong>页内偏移量W</strong></p>
</li>
<li>
<p>系统为每个进程建立一张<strong>页面映射表</strong>，简称页表。进程的每个页面对应一个页表项，每个页表项由页号和块号组成，它记录了页面在内存中对应的物理块号</p>
</li>
<li>
<p>地址变换机构的任务是将逻辑地址转换为内存中的物理地址</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/655075ec518b0b5114bfeea7c022824d5d016090f65b6e20fdab5e404c5f921b/68747470733a2f2f74656c6567726170682d696d6167652d3662342e70616765732e6465762f66696c652f3733313731316537626230343933373733643665622e706e67"><img src="https://camo.githubusercontent.com/655075ec518b0b5114bfeea7c022824d5d016090f65b6e20fdab5e404c5f921b/68747470733a2f2f74656c6567726170682d696d6167652d3662342e70616765732e6465762f66696c652f3733313731316537626230343933373733643665622e706e67" alt="flower" data-canonical-src="https://telegraph-image-6b4.pages.dev/file/731711e7bb0493773d6eb.png" style="max-width: 100%;"></a></p>
</li>
<li>
<p>为了提高地址转换的速度，在系统中设置一个页表寄存器PTR，存放页表在内存的始址F和页表长度M</p>
</li>
<li>
<p>进程未执行时，页表的始址和页表长度存放在本进程的PCB中，当进程被调度执行时，才将页表始址和页表长度装入页表寄存器中</p>
</li>
<li>
<p>分页管理方式的问题</p>
<ul>
<li>每次访存操作都需要进行逻辑地址到物理地址的转换，地址转换过程必须足够快，否则访存速度会降低</li>
<li>每个进程引入页表，用于存储映射机制，页表不能太大，否则内存利用率会降低</li>
</ul>
</li>
<li>
<p>在地址变换机构中增设一个具有并行查找能力的高速缓冲存储器——<strong>TLB/快表/相联存储器</strong>，用来存放当前访问的若干项，以加速地址变换的过程。主存中的页表常称为慢表<br>
页表起址F页表长度M页表寄存器页号P页表偏移量W逻辑地址A&gt;+…………b………………P……页号块号慢表Wb……b…………P……页号块号快表</p>
</li>
<li>
<p>增加快表后，地址变换过程为：</p>
<div class="highlight highlight-source-mermaid"><pre class="notranslate"><span class="pl-k">graph</span> <span class="pl-c1">LR</span>
	<span class="pl-ent">A</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>逻辑地址<span class="pl-pds"><span class="pl-sg">)</span></span></span><span class="pl-k">--&gt;</span><span class="pl-ent">B</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>页号<span class="pl-pds"><span class="pl-sg">)</span></span></span><span class="pl-k">--&gt;</span><span class="pl-ent">C</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">{</span></span>存在于快表<span class="pl-pds"><span class="pl-sg">}</span></span></span><span class="pl-k">--&gt;</span><span class="pl-k">|</span><span class="pl-s">是</span><span class="pl-k">|</span><span class="pl-ent">D</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>页框号<span class="pl-pds"><span class="pl-sg">)</span></span></span><span class="pl-k">--&gt;</span><span class="pl-ent">G</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>物理地址<span class="pl-pds"><span class="pl-sg">)</span></span></span>
	<span class="pl-ent">C</span><span class="pl-k">--&gt;</span><span class="pl-k">|</span><span class="pl-s">否</span><span class="pl-k">|</span><span class="pl-ent">E</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>访问慢表<span class="pl-pds"><span class="pl-sg">)</span></span></span><span class="pl-k">--&gt;</span><span class="pl-ent">D</span>
	<span class="pl-ent">A</span><span class="pl-k">--&gt;</span><span class="pl-ent">F</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">(</span></span>页内偏移量<span class="pl-pds"><span class="pl-sg">)</span></span></span><span class="pl-k">--&gt;</span><span class="pl-ent">G</span></pre></div>
</li>
<li>
<p>分页管理方式两个问题</p>
<ul>
<li>页表占用连续内存空间：对于页表所需的内存空间，采用离散分配方式，用一张索引表来记录各个页表的存放位置，该索引表称为外层页表/页目录</li>
<li>页表占用内存过多：只将当前需要的部分页表项调入内存，其余的页表项仍驻留磁盘，需要时再调入</li>
</ul>
</li>
<li>
<p>为了方便实现地址变换，需要在系统中增设一个外层页表寄存器/页目录基址寄存器，用于存放页目录始址。将逻辑地址中的页目录号作为页目录的索引，从中找到对应页表的始址，再用二级页号作为页表分页的索引，从中找到对应的页表项；将页表项中的物理块号和页内偏移拼接，即为物理地址，再用该地址访问内存单元</p>
</li>
</ol>
<h3>基本分段存储管理</h3>
<ol>
<li>
<p>分段系统将用户进程的逻辑地址空间划分为大小不等的段，段内要求连续，段间不要求连续</p>
</li>
<li>
<p>分段存储管理的逻辑地址由段号S与段内偏移量W两部分组成</p>
</li>
<li>
<p>在页式系统中，逻辑地址的页号和页内偏移量对用户是透明的，但在分段系统中，段号和段内偏移量必须由用户显式提供</p>
</li>
<li>
<p>每个进程都有一张逻辑空间与内存空间映射的段表，进程的每个段对应一个段表项，段表项记录了该段在内存中的始址和段的长度</p>
</li>
<li>
<p>为了实现进程从逻辑地址到物理地址的变换功能，在系统中设置了一个段表寄存器，用于存放段表始址F和段表长度M</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/81ebe6415a103fe84940ff7bc7f0e2c0b30c5f147327150642bac7062ec28913/68747470733a2f2f74656c6567726170682d696d6167652d3662342e70616765732e6465762f66696c652f3038346266656563623366356661653063316262642e706e67"><img src="https://camo.githubusercontent.com/81ebe6415a103fe84940ff7bc7f0e2c0b30c5f147327150642bac7062ec28913/68747470733a2f2f74656c6567726170682d696d6167652d3662342e70616765732e6465762f66696c652f3038346266656563623366356661653063316262642e706e67" alt="flower" data-canonical-src="https://telegraph-image-6b4.pages.dev/file/084bfeecb3f5fae0c1bbd.png" style="max-width: 100%;"></a></p>
</li>
<li>
<p>分页和分段的对比</p>
<ul>
<li>相同点
<ul>
<li>都是非连续分配方式</li>
<li>都要通过地址映射机构实现地址变换</li>
</ul>
</li>
<li>不同点
<ul>
<li>页是信息的物理单位，分页的主要目的是提高内存利用率，分页完全是系统的行为，对用户不可见。段是信息的逻辑行为，分段的主要目的是更好地满足用户需求，用户按照逻辑关系将程序划分为若干段，分段对用户可见</li>
<li>页的大小是固定的，由系统决定；段的长度不固定，由程序决定</li>
<li>分页管理的地址空间是一维的；分段管理的地址空间是二维的</li>
</ul>
</li>
</ul>
</li>
<li>
<p>分段系统中信息的共享：只要在每个进程的段表中设置一个段表项，指向被共享的同一物理段</p>
</li>
<li>
<p>分段系统的保护方法：</p>
<ul>
<li>存取保护控制</li>
<li>地址越界保护</li>
</ul>
</li>
</ol>
<h3>段页式存储管理</h3>
<ol>
<li>
<p>在段页式系统中，进程的地址空间首先被分为若干逻辑段，每段都有自己的段号，然后将每段分成若干大小固定的页。</p>
</li>
<li>
<p>对内存空间的管理仍然和分页存储管理一样，将其分成若干和页面大小相同的存储块，对内存的分配以存储块为单位</p>
</li>
<li>
<p>在段页式系统中，进程的逻辑地址分为三部分：段号S、页号P和页内偏移量W</p>
</li>
<li>
<p>为了实现地址变换，系统为每个进程建立一张段表，每个段对应一个段表项，每个段表项至少包含段号、页表长度和页表始址；每个段有一张页表，每个页表项至少包含页号和块号。系统中还应有一个段表寄存器，指出进程的段表始址和段表长度</p>
</li>
<li>
<p>在进行地址变换时，首先通过段表查到页表始址，然后通过页表找到物理块号，最后形成物理地址</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/85f2c9aa58eaa1b3dca7a18d79bec6099b1fb2bfd154fa0d04d12bf5bddd9d78/68747470733a2f2f74656c6567726170682d696d6167652d3662342e70616765732e6465762f66696c652f3339343637333338613535656337356639653762632e706e67"><img src="https://camo.githubusercontent.com/85f2c9aa58eaa1b3dca7a18d79bec6099b1fb2bfd154fa0d04d12bf5bddd9d78/68747470733a2f2f74656c6567726170682d696d6167652d3662342e70616765732e6465762f66696c652f3339343637333338613535656337356639653762632e706e67" alt="flower" data-canonical-src="https://telegraph-image-6b4.pages.dev/file/39467338a55ec75f9e7bc.png" style="max-width: 100%;"></a></p>
</li>
</ol>
<h2>虚拟内存管理</h2>
<h3>虚拟内存的基本概念</h3>
<ol>
<li>传统存储管理方式的特征
<ul>
<li>一次性：作业必须一次性装入内存才能运行。这会导致两个问题：当作业很大无法装入内存时，作业无法运行；当大量作业要求运行时，由于内存不足，只有少数作业先运行，导致并发度下降</li>
<li>驻留性：作业被装入内存后，就一直驻留在内存中，直到程序运行结束。运行中进程因等待I/O而被阻塞，可能处于长期等待状态</li>
</ul>
</li>
<li>局部性原理
<ul>
<li>时间局部性原理：引用过一次的内存位置很可能在不远的将来再被多次引用</li>
<li>空间局部性原理：如果一个内存位置被引用了一次，那么程序很可能在不远的将来引用其附近的一个内存位置</li>
</ul>
</li>
<li>在执行程序过程中，当访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序，这个过程就是请求<strong>调页/调段</strong>。当内存空间不够时，由操作系统负责将内存中暂时用不到的信息换出到外存，从而腾出空间存放将要调入内存的信息，这个过程就是<strong>页面置换/段置换</strong></li>
<li>虚拟存储器的主要特征
<ul>
<li>多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存；当运行到尚未调入的那部分程序或数据时，再将它们调入</li>
<li>对换性：在作业运行时无需常驻内存，而是允许在作业运行过程中，将那些暂不使用的程序和数据从内存调至外存的对换区，待以后需要时再将它们从外存调至内存</li>
<li>虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量远大于实际容量</li>
</ul>
</li>
<li>虚拟内存的实现有以下三种方式：
<ul>
<li>请求分页存储管理</li>
<li>请求分段存储管理</li>
<li>请求段页式存储管理</li>
</ul>
</li>
<li>不管哪种方式，都需要一定的硬件支持：
<ul>
<li>一定容量的内存和外存</li>
<li>页表机制/段表机制作为主要的数据结构</li>
<li>中断机构，当用户程序要访问的尚未调入内存的部分时，产生中断</li>
<li>地址变换机构，逻辑地址到物理地址的变换</li>
</ul>
</li>
</ol>
<h3>请求分页管理方式</h3>
<ol>
<li>
<p>请求分页系统中的页表项：页号+物理块号+状态位P+访问字段A+修改位M+外存地址</p>
<ul>
<li>状态位P：标记该页是否已调入内存</li>
<li>访问字段A：记录本页在一段时间内被访问的次数，或记录本页最近已有多长时间未被访问</li>
<li>修改位M：标记该页在调入内存后是否被修改过</li>
<li>外存地址：记录该页在外存地存放地址，通常是物理块号</li>
</ul>
</li>
<li>
<p>缺页中断机构</p>
<ul>
<li>在请求分页系统中，每当要访问的页面不在内存时，便产生一个缺页中断，请求操作系统的缺页中断处理程序处理。此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列。若内存中有空闲页框，则为进程分配一个页框，将所缺页面从外存装入页框，并修改页表中的相应表项，若内存中没有空闲页框，则有页面置换算法选择一个页面淘汰，若该页在内存期间被修改过，则还要将其写回外存。未被修改过的页面不用写回</li>
<li>缺页中断与中断的区别：
<ul>
<li>在指令执行期间而非一条指令执行完后产生和处理中断，属于内部异常</li>
<li>一条指令在执行期间，可能产生多次缺页中断</li>
</ul>
</li>
</ul>
</li>
<li>
<p>地址变换机构</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/4cee0d57fb758d1dd2a668d37640d1462fb971533964ce32be5b03e47230964b/68747470733a2f2f74656c6567726170682d696d6167652d3662342e70616765732e6465762f66696c652f3661386664396238623463666430636535376636642e706e67"><img src="https://camo.githubusercontent.com/4cee0d57fb758d1dd2a668d37640d1462fb971533964ce32be5b03e47230964b/68747470733a2f2f74656c6567726170682d696d6167652d3662342e70616765732e6465762f66696c652f3661386664396238623463666430636535376636642e706e67" alt="flower" data-canonical-src="https://telegraph-image-6b4.pages.dev/file/6a8fd9b8b4cfd0ce57f6d.png" style="max-width: 100%;"></a></p>
</li>
</ol>
<h3>页框分配</h3>
<ol>
<li>
<p>给一个进程分配的页框集合就是这个进程的驻留集</p>
<ul>
<li>驻留集越小，驻留在内存中的进程就越多，可以提高多道程序的并发度，但分配给每个进程的页框太少，会导致缺页率较高，CPU需耗费大量时间来处理缺页</li>
<li>驻留集越大，当分配给进程的页框超过某个数目时，再为进程增加页框对缺页率的改善是不明显的，反而只能是浪费内存空间，还会导致多道程序并发度的下降</li>
</ul>
</li>
<li>
<p>在请求分页系统中，可采取两种内存分配策略</p>
<ul>
<li>固定分配策略：为每个进程分配固定数目的物理块，在进程运行期间都不改变</li>
<li>可变分配策略：先为每个进程分配一定数目的物理块，在进程运行期间可根据情况适当地增加或减少</li>
</ul>
<p>在进行置换时，也可采取两种策略</p>
<ul>
<li>局部置换：若进程在运行中发生缺页，则只能从分配给进程在内存中的页面中选出一页换出，然后再调入一页，以保证分配给该进程的内存空间不变</li>
<li>全局置换：若进程在运行中发生缺页，则系统从空闲物理块队列中取出一块分配给该进程，并将所缺页调入</li>
</ul>
</li>
<li>
<p>页框分配策略：</p>
<ul>
<li><strong>固定分配局部置换</strong>：难以确定应为每个进程分配的物理块数目；太少会频繁出现缺页中断，太多会降低CPU和其他资源的利用率</li>
<li><strong>可变分配全局置换</strong>：比固定分配局部置换更加灵活，可以动态增加进程的物理块，但它会盲目地给进程增加物理块，从而导致系统多道程序的并发能力下降</li>
<li><strong>可变分配局部置换</strong>：若进程在运行中频繁地发生缺页中断，则系统再为该进程分配若干物理块，直到该进程的缺页率趋于适当程度；反之，若进程在运行中的缺页率特别低，则可适当减少分配给该进程的物理块，但不能引起缺页率明显增加</li>
</ul>
</li>
<li>
<p>采用固定分配策略时，将系统中的空闲物理块分配给各个进程，可采用下述几种方法：</p>
<ul>
<li>平均分配算法：将系统中所有可供分配的物理块平均分配给各个进程</li>
<li>按比例分配算法：根据进程的大小按比例分配物理块</li>
<li>优先权分配算法：为重要和紧迫的进程分配较多的物理块</li>
</ul>
</li>
<li>
<p>为确定系统将进程运行时所缺的页面调入内存的时机，可采用以下两种调页策略：</p>
<ul>
<li>预调页策略：根据局部性原理，一次调入若然个相邻的页面会比一次调入一页更高效。但若提前调入的页面中大多数都未被访问，则又是低效的。主要用于进程的首次调入</li>
<li>请求调页策略：进程在运行中需要访问的页面不在内存，便提出请求，由系统将其所需页面调入内存。缺点是每次仅调入一页，增加了磁盘I/O开销</li>
</ul>
<p>预调页策略实际上在运行前调入；请求调页策略是运行期间调入</p>
</li>
<li>
<p>请求分页系统的外存分为两部分</p>
<ul>
<li>文件区：存放文件，采用离散分配方式，I/O速度较慢</li>
<li>对换区/交换区：用于存放兑换页面，采用连续分配方式，I/O速度较快</li>
</ul>
<p>发生缺页请求时，系统调入页面来源</p>
<ul>
<li>系统拥有足够的对换区空间：可以全部从对换区调入所需页面，以提高调页速度。在进程运行前，需将与该进程有关的文件从文件区复制到对换区</li>
<li>系统缺少足够的对换区空间：凡是不会被修改的文件直接从文件区调入；当换出这些页面时，由于它们不会被修改而不必再换出。但对于那些可能被修改的部分，在将它们换出时必须放在对换区，以后需要时再从对换区调入</li>
<li>UNIX方式：与进程有关的文件都在文件区，因此未运行过的页面都应从文件区调入。曾经运行过但又被换出的页面应该从对换区调入。进程请求的共享页面若被其他进程调入主存，则不需要再从对换区调入</li>
</ul>
</li>
</ol>
<h3>页面置换算法</h3>
<ol>
<li>最佳置换算法
<ul>
<li>选择淘汰的页面是以后永不使用或最长时间内不再被访问的页面</li>
</ul>
</li>
<li>先进先出页面置换算法
<ul>
<li>选择淘汰的页面时最早进入内存的页面</li>
<li>会产生分配的物理块增多，缺页次数不减反增的异常现象，称为Belady异常</li>
</ul>
</li>
<li>最近最久未使用置换算法
<ul>
<li>选择淘汰的页面时最近最长时间未使用的页面</li>
<li>性能较好，但需要寄存器和栈的硬件支持</li>
</ul>
</li>
<li>简单的CLOCK置换算法
<ul>
<li>为每个页面设置一个访问位，当某页首次被装入或被访问时，其访问位被置为1.</li>
<li>将内存中的页面链接成一个循环队列，并有一个替换指针与之相关联。当某一页被替换时，该指针被设置指向被替换页面的下一页。在选择淘汰一页时，只需检查页面的访问位：若为0，就选择该页换出；若为1，则将它置为0，暂不换出，依此检查下一个页面。当检查到队列中的最后一个页面时，若其访问为仍为1，则返回到队首去循环检查</li>
</ul>
</li>
<li>改进CLOCK置换算法
<ul>
<li>在选择页面换出时，优先考虑既未使用过又未修改过的页面。由访问位A和修改位M可以组合成下面四种类型的页面：
<ul>
<li>(A, M) = (0, 0)：未被访问，未被修改</li>
<li>(A, M) = (0, 1)：未被访问，已被修改</li>
<li>(A, M) = (1, 0)：已被访问，未被修改</li>
<li>(A, M) = (1, 1)：已被访问，已被修改</li>
</ul>
</li>
<li>算法执行过程如下：
<ul>
<li>从指针的当前位置开始，循环扫描队列，寻找(0, 0)的页面，将遇到的第一个页面作为淘汰页。扫描期间不修改访问位A</li>
<li>若第一步失败，则进行第二轮扫描，寻找(0, 1)的页面。将遇到的第一个页面作为淘汰页。在扫描期间修改访问位A为0</li>
<li>若第二步失败，则将将指针返回始址，寻找(0, 0)的页面，将遇到的第一个页面作为淘汰页。若查找失败，则寻找(0, 1)的页面，将遇到的第一个页面作为淘汰页</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3>抖动和工作集</h3>
<ol>
<li>抖动/颠簸：刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出内存</li>
<li>系统发生抖动的根本原因：分配给每个进程的物理块太少，不能满足进程正常运行的物理要求，只是每个进程在运行时频繁地出现缺页，必须请求系统将所缺页面调入内存</li>
<li>工作集是指在某段时间内，进程要访问的页面集合。一般来说，工作集W可由时间t和工作集窗口大小$\Delta$来确定</li>
<li>工作集反映了进程在接下来的一段时间内很有可能会频繁访问的页面集合，因此驻留集大小不能小于工作集，否则进程在运行过程中会频繁缺页</li>
</ol>
<h3>内存映射文件</h3>
<ol>
<li>内存映射文件是操作系统向应用程序提供的一个系统调用，在磁盘文件与进程的虚拟地址空间之间建立映射关系</li>
<li>进程通过该系统调用，将一个文件映射到其虚拟地址空间的某个区域，之后就用访问内存的方式读写文件。将一个文件当作内存中的一个大字符数组来访问，而不通过文件I/O操作来访问</li>
<li>映射进程的页面时，不会实际读入文件的内容，而只在访问页面时才被每次一页地读入。当进程退出或关闭文件映射时，所有被改动的页面才被写回磁盘文件</li>
<li>共享内存是通过映射相同文件到通信进程的虚拟地址空间来实现的。当多个进程映射到同一文件时，各进程的虚拟地址空间都是相互独立地，但操作系统将对应的这些虚拟地址空间映射到相同的物理内存</li>
<li>内存映射文件的好处：
<ul>
<li>使程序员的编程更简单，已建立映射的文件只需要按访问内存的方式读写</li>
<li>方便多个进程共享同一个磁盘文件</li>
</ul>
</li>
</ol>
<h3>错题</h3>
<ol>
<li>
<p>考虑页面置换算法，系统有m个物理块供调度，初始时全空，页面引用串长度为p，包含了n个不同的页号，无论用什么算法，缺页次数不会少于(  )</p>
<p>A. m</p>
<p>B. p</p>
<p>C. n</p>
<p>D. min(m, n)</p>
</li>
<li>
<p>导致LRU算法实现起来耗费搞得原因是(  )</p>
<p>A. 需要硬件的特殊支持</p>
<p>B. 需要特殊的中断处理程序</p>
<p>C. 需要在页表中表明特殊的页类型</p>
<p>D. 需要对所有的页进行排序</p>
</li>
<li>
<p>下列选项中，(  )不是页面换进换出效率的影响因素</p>
<p>A. 页面置换算法</p>
<p>B. 已修改页面写回磁盘的频率</p>
<p>C. 磁盘数据读入内存的频率</p>
<p>D. CPU与内存交换的速度</p>
</li>
<li>
<p>已知系统为32位实地址，采取48位虚拟地址，页面大小为4KB，页表项大小为8B。假设系统使用纯页式存储，则要采用(  )级页表，页内偏移(  )位</p>
<p>A. 3, 12</p>
<p>B. 4, 14</p>
<p>C. 4, 12</p>
<p>D. 4, 14</p>
</li>
<li>
<p>在请求分页存储管理系统中，为了提高TLB命中率，可行的方法是(  )</p>
<p>I. 增大TLB容量</p>
<p>II. 采用多级页表</p>
<p>III. 增大页面大小</p>
<p>IV. 减小页面大小</p>
<p>A. I和III</p>
<p>B. I和IV</p>
<p>C. I、II和III</p>
<p>D. II和III</p>
</li>
<li>
<p>在缺页处理过程中，操作系统执行的操作可能是(  )</p>
<p>I. 修改页表</p>
<p>II. 磁盘I/O</p>
<p>III. 分配页框</p>
<p>A. 仅I、II</p>
<p>B. 仅II</p>
<p>C. 仅III</p>
<p>D. I、II和III</p>
</li>
<li>
<p>若用户进程访问内存时产生缺页，则下列选项中，操作系统可能执行的操作是(  )</p>
<p>I. 处理越界错</p>
<p>II. 置换页</p>
<p>III. 分配内存</p>
<p>A. 仅I、II</p>
<p>B. 仅II、III</p>
<p>C. 仅I、III</p>
<p>D. I、II和III</p>
</li>
<li>
<p>某请求分页存储系统的页大小为4KB，按字节编址。系统给进程P分配2个固定的页框，并采用改进型Clock置换算法，进程P页表的部分内容见下表</p>
<markdown-accessiblity-table><table role="table">
<thead>
<tr>
<th align="center">页号</th>
<th align="center">页框号</th>
<th align="center">存在位<br>1：存在；0：不存在</th>
<th align="center">访问位<br>1：访问；0：未访问</th>
<th align="center">修改位<br>1：修改；0：未修改</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">20H</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">60H</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">80H</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p>若P访问虚拟地址位02A01H的存储单元，则经过地址变换后得到的物理地址是(  )</p>
<p>A. 00A01H</p>
<p>B. 20A01H</p>
<p>C. 60A01H</p>
<p>D. 80A01H</p>
</li>
</ol></div>
<div style="font-size:small;margin-top:8px;float:right;"></div>

<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>

</div>
    <div id="footer"><div id="footer1">Copyright © <span id="copyrightYear"></span> <a href="https://wlkla.github.io/onebuaaer.github.io">我在人世间踽踽独行</a></div>
<div id="footer2">
    <span id="runday"></span><span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a></span>
</div>

<script>
var now=new Date();
document.getElementById("copyrightYear").innerHTML=now.getFullYear();

if("09/02/2024"!=""){
    var startSite=new Date("09/02/2024");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";
}
</script></div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z', 'copy': 'M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z', 'check': 'M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);



function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","wlkla/onebuaaer.github.io");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const createClipboardHTML = (codeContent, additionalClasses = '') => `
        <pre class="notranslate"><code class="notranslate">${codeContent}</code></pre>
        <div class="clipboard-container position-absolute right-0 top-0 ${additionalClasses}">
            <clipboard-copy class="ClipboardButton btn m-2 p-0" role="button" style="display: inherit;">
                <svg height="16" width="16" class="octicon octicon-copy m-2"><path d="${IconList["copy"]}"></path></svg>
                <svg height="16" width="16" class="octicon octicon-check color-fg-success m-2 d-none"><path d="${IconList["check"]}"></path></svg>
            </clipboard-copy>
            <div class="copy-feedback">Copied!</div>
        </div>
    `;

    const handleCodeElements = (selector = '') => {
        document.querySelectorAll(selector).forEach(codeElement => {
            const codeContent = codeElement.innerHTML;
            const newStructure = document.createElement('div');
            newStructure.className = 'snippet-clipboard-content position-relative overflow-auto';
            newStructure.innerHTML = createClipboardHTML(codeContent);

            const parentElement = codeElement.parentElement;
            if (selector.includes('highlight')) {
                parentElement.insertBefore(newStructure, codeElement.nextSibling);
                parentElement.removeChild(codeElement);
            } else {
                parentElement.parentElement.replaceChild(newStructure, parentElement);
            }
        });
    };

    handleCodeElements('pre.notranslate > code.notranslate');
    handleCodeElements('div.highlight > pre.notranslate');

    let currentFeedback = null;
    document.querySelectorAll('clipboard-copy').forEach(copyButton => {
        copyButton.addEventListener('click', () => {
            const codeContent = copyButton.closest('.snippet-clipboard-content').innerText;
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = codeContent;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            document.execCommand('copy');
            document.body.removeChild(tempTextArea);

            const copyIcon = copyButton.querySelector('.octicon-copy');
            const checkIcon = copyButton.querySelector('.octicon-check');
            const copyFeedback = copyButton.nextElementSibling;

            if (currentFeedback && currentFeedback !== copyFeedback) {currentFeedback.style.display = 'none';}
            currentFeedback = copyFeedback;

            copyIcon.classList.add('d-none');
            checkIcon.classList.remove('d-none');
            copyFeedback.style.display = 'block';
            copyButton.style.borderColor = 'var(--color-success-fg)';

            setTimeout(() => {
                copyIcon.classList.remove('d-none');
                checkIcon.classList.add('d-none');
                copyFeedback.style.display = 'none';
                copyButton.style.borderColor = '';
            }, 2000);
        });
    });
});

</script>
<script src='https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs'></script><script src='https://onebuaaer.us.kg/assets/backtotop.js'></script><script src='https://onebuaaer.us.kg/assets/lazyload.js'></script><script>MathJax = {tex: {inlineMath: [["$", "$"]]}};</script><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

</html>
