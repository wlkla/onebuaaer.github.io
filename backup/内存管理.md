# 内存管理

## 内存管理概念

### 内存管理的基本原理和要求

1. 内存管理的主要功能

   ```mermaid
   graph TB
   	A(内存管理)-->B(内存空间的分配和回收)
   	A-->C(地址转换)
   	A-->D(内存空间的扩充)
   	A-->E(内存共享)
   	A-->F(存储保护)
   ```

2. 程序的链接与装入

   - 创建进程首先要将程序和数据装入内存，通常有以下步骤

     ```mermaid
     graph LR
     	A(用户源代码)-->|编译|B(目标模块)-->|链接|C(装入模块)-->|装入|D(运行)
     ```

     编译：由**编译程序**将用户源代码编译成若干目标模块

     链接：由**链接程序**将编译后形成的一组目标模块，以及它们所需的库函数链接在一起，形成一个完成的装入模块

     装入：由**装入程序**将装入模块装入内存运行

3. 将一个装入模块装入内存有三种装入方式：

     ```mermaid
     graph LR
     	A(装入方式)-->B(绝对装入)
     	A-->C(可重定位装入/静态重定位)
     	A-->D(动态运行时装入/动态重定位)
     ```

     - 绝对装入：只适用于单道程序环境。在编译时，编译程序直接产生绝对地址的目标代码，装入程序按照装入模块的地址，将程序和数据装入内存，不需要对程序和数据的地址进行修改
     - 可重定位装入：经过编译、链接的装入模块的起始地址从0开始，装入时根据内存的当前情况将装入模块装入内存的适当位置，同时对目标程序中的相对地址的修改过程称为重定位/地址转换
     - 动态运行时装入：装入程序将装入模块装入内存后，只有在程序执行时才将装入模块中的相对地址转换为绝对地址。因此装入内存后的所有地址均为相对地址，需要一个重定位寄存器的支持

4. 对目标模块进行链接时，链接方式分类：

     ```mermaid
     graph TB
     	A(模块链接方式)-->B(静态链接)
     	A-->C(装入时动态链接)
     	A-->D(运行时动态链接)
     ```

     - 静态链接：在程序运行前，先将各目标模块及它们所需要的库函数链接成一个完整的装入模块，以后不再拆开
       将几个目标模块装配成一个装入模块时，需要解决的问题：修改相对地址；变换外部调用符号
     - 装入时动态链接：将用户源程序编译后所得到的一组目标模块装入内存时采用边装入边链接的方式
       优点：便于修改和更新，便于实现对目标模块的共享
     - 运行时动态链接：在程序执行中需要某目标模块时，才对它进行链接。凡是程序执行中未用到的目标模块都不会被调入内存和链接到装入模块上
       优点：能加快程序的装入过程，还可节省内存空间

5. 编译后，每个目标模块都从0号单元开始编址，称为该目标模块的相对地址/逻辑地址。当链接程序将各个模块链接成一个完整的可执行目标程序时，链接程序顺序依次按各个模块的相对地址构成统一的从0号单元开始编制的逻辑地址空间/虚拟地址空间

6. 物理地址空间是指内存中物理单元的集合，进程在运行时执行指令和访问数据，都要通过物理地址从主存中存取。将可执行代码装入内存时，必须通过地址转换将逻辑地址转换为物理地址，这个过程称为**地址重定位**

7. 操作系统通过**内存管理部件(MMU)**将进程使用的逻辑地址转换为物理地址

8. 一个进程的内存映像组成：

     ```mermaid
     graph LR
     	A(内存映像)-->B(代码段)-->G(二进制代码，可以被共享)
     	A-->C(数据段)-->H(程序运行时处理的对象)
     	A-->D(PCB)-->I(用来实现进程管理)
     	A-->E(堆)-->J(用来存放动态分配的变量)
     	A-->F(栈)-->K(用来实现函数调用)
     ```

9. 内存保护：确保每个进程都有一个单独的内存空间

10. 内存保护的方法：

     - 在CPU中设置一对上、下限寄存器，存放用户进程在主存中的上限地址和下限地址，每当CPU要访问一个地址时，判断是否越界

     - 采用重定位寄存器(基地址寄存器)和界地址寄存器(限长寄存器)进行越界检查。重定位寄存器存放进程的起始物理地址，界地址寄存器存放进程的最大逻辑地址

       加载重定位寄存器和界地址寄存器时必须使用特权指令，只有操作系统内核才可以加载这两个寄存器

11. 可重入代码/纯代码：一种允许多个进程同时访问但不允许被任何进程修改的代码。可以为每个进程配备局部数据区，将在执行中可能改变的部分复制到该数据区，这样程序在执行时就只需要对私有数据区中的内存进行修改，不去改变共享的代码

### 连续分配管理方式

1. 连续分配方式是指为一个用户程序分配为一个连续的内存空间

   ```mermaid
   graph TB
   	A(连续分配方式)-->B(单一连续分配)
   	A-->C(固定分区分配)
   	A-->D(动态分区分配)
   ```

2. 单一连续分配

   - 内存被分为系统区和用户区
   - 系统区仅供操作系统使用，通常在低地址部分
   - 用户区仅有一道用户程序
   - 优点：简单、无外部碎片；不需要内存保护
   - 缺点：只能用于单用户、单任务的操作系统中；有内部碎片；存储器的利用率极低

3. 固定分区分配

   - 将用户内存空间划分为若干固定大小的分区，每个分区只装入一道作业。当有空闲分区时，便可再从外存的后备作业队列中选择适当大小的作业装入该分区

   - 划分分区的方法：

     - 分区大小相等
     - 分区大小不等

   - 为了便于分配和回收，建立一张分区使用表，通常按分区大小排列，各表项包括对应分区的起始地址，大小和状态

     | 分区号 | 大小 | 始址 |               状态                |
     | :----: | :--: | :--: | :-------------------------------: |
     |   1    |  12  |  20  |  <font color='red'>已分配</font>  |
     |   2    |  32  |  32  | <font color='green'>未分配</font> |
     |   3    |  64  |  64  | <font color='green'>未分配</font> |

   - 存在的问题：

     - 程序太大放不到任何一个分区
     - 程序太小，造成空间浪费，产生内部碎片，空间利用率低

4. 动态分区分配

   - 指进程装入内存时，根据进程的实际需要，动态分配内存，并使分区的大小正好适合进程的需要

   - 随着时间的推移，内存中会产生越来越多的外部碎片，导致内存的利用率随之下降

   - 在动态分区分配中，设置一张空闲分区表。分配内存时，检索空闲分区表；回收内存时会出现以下四种情况：

     - 回收区与前一空闲分区相邻，将两个分区合并并修改前一分区表项
     - 回收区与后一空闲分区相邻，将两个分区合并并修改后一分区表项
     - 回收区与前后空闲分区均相邻，将三个分区合并并修改前一分区表项，删除后一分区表项
     - 回收区前后分区均不空闲，则在回收区新建一个表项并插入空闲分区表

   - 按照从空闲分区表中选出分区的方法不同，将分区检索方法分为：**顺序分配算法**和**索引分配算法**

   - 顺序分配算法

     - 首次适应算法(First Fit)：空闲分区按地址递增的次序排列。每次分配内存时，顺序查找第一个能满足大小的空闲空间。

       缺点：使内存低地址部分出现许多小碎片，每次分配查找时都要经过这些分区，增加了开销

     - 临近适应算法(Next Fit)：类似首次适应算法，分配内存时从上次查找结束的位置开始查找。
       特点：让内存低、高地址部分的空闲空间以同等概率被分配，划分为小分区，导致内存高地址部分没有大空闲分区可用

     - 最佳适应算法(Best Fit)：空闲分区安荣零递增的次序排列。每次分配内存时，顺序查找第一个能满足大小的空闲空间。

       缺点：会产生很多外部碎片

     - 最坏适应算法(Worst Fit)：空闲分区按容量递减的次序排列。每次分配内存时，顺序查找第一个能满足要求的空闲空间。

       缺点：会很快导致没有大空闲分区可用

   - 索引分配算法

     - 快速适应算法：首先根据进程的长度，在索引表中找到能容纳它的最小空闲分区链表，然后从链表中取出第一块进行分配

       优点：查找效率高，不产生内部碎片

       缺点：回收分区时，要有效地合并分区，算法比较复杂，系统开销较大

     - 伙伴系统：规定所有分区的大小均为$2^k$(k为整数)。当需要为进程分配大小为n的分区时($2^{i-1}\lt n\leqslant 2^i$)，在大小为$2^i$的空闲分区链中查找。若找到，则分配给进程，若找不到，在大小为$2^{i+1}$的空闲分区中查找。若存在大小为$2^{i+1}$的分区，则将其分为两个分区，整两个分区称为一堆伙伴，其中一个用于分配，而将两一个加入大小为$2^i$的空闲分区表。若不存在，则继续查找，直到找到为止。回收时，也可能需要对伙伴分区进行合并

     - 哈希算法：根据空闲分区链表的分布规律，建立哈希函数，构建一张以空闲分区大小为关键字的哈希表，每个表项记录一个对应空闲分区表的头指针。分配时，根据所需分区大小，通过哈希函数计算得到哈希表中的位置，从中得到相应的空闲分区链表

### 基本分页存储管理

1. 将内存空间分为若干固定大小的分区，称为页框、页帧或物理块。进程的逻辑地址空间也分为与块大小相等的若干区域，称为页或页面

2. 操作系统以页框为单位为各个进程分配内存空间

3. 进程的逻辑地址空间中的每个页面有一个编号，称为页号，从0开始；内存空间中的每个页框也有一个编号，称为页框号/物理块号，也从0开始

4. 页面太小会使进程的页面数过多，这样页表就会过长，占用大量内存，也会增加硬件地址转换的开销，降低页面换入/换出的效率；页面过大又会使页内碎片增多，降低内存的利用率

5. 分页存储管理的逻辑地址结构：前一部分为**页号P**，后一部分为**页内偏移量W**

6. 系统为每个进程建立一张**页面映射表**，简称页表。进程的每个页面对应一个页表项，每个页表项由页号和块号组成，它记录了页面在内存中对应的物理块号

7. 地址变换机构的任务是将逻辑地址转换为内存中的物理地址
   
   ![flower](https://telegraph-image-6b4.pages.dev/file/731711e7bb0493773d6eb.png)
   
8. 为了提高地址转换的速度，在系统中设置一个页表寄存器PTR，存放页表在内存的始址F和页表长度M

9. 进程未执行时，页表的始址和页表长度存放在本进程的PCB中，当进程被调度执行时，才将页表始址和页表长度装入页表寄存器中

10. 分页管理方式的问题

    - 每次访存操作都需要进行逻辑地址到物理地址的转换，地址转换过程必须足够快，否则访存速度会降低
    - 每个进程引入页表，用于存储映射机制，页表不能太大，否则内存利用率会降低

11. 在地址变换机构中增设一个具有并行查找能力的高速缓冲存储器——**TLB/快表/相联存储器**，用来存放当前访问的若干项，以加速地址变换的过程。主存中的页表常称为慢表
    <svg width="680" height="454" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="hidden"><g><rect x="0" y="0" width="680" height="453.722" fill="#FFFFFF" fill-opacity="0"/><rect x="24" y="79.1259" width="120" height="26.0414" stroke="#042433" stroke-width="1.66585" stroke-miterlimit="8" fill="none"/><text font-family="DengXian,DengXian_MSFontService,sans-serif" font-weight="400" font-size="15" transform="matrix(1 0 0 1.00159 50.8026 98)">页表起址F</text><rect x="144" y="79.1259" width="120" height="26.0414" stroke="#042433" stroke-width="1.66585" stroke-miterlimit="8" fill="none"/><text font-family="DengXian,DengXian_MSFontService,sans-serif" font-weight="400" font-size="15" transform="matrix(1 0 0 1.00159 169.039 98)">页表长度M</text><text font-family="DengXian,DengXian_MSFontService,sans-serif" font-weight="400" font-size="15" transform="matrix(1 0 0 1.00159 93.5483 59)">页表寄存器</text><rect x="419" y="147.234" width="83.0001" height="26.0415" stroke="#042433" stroke-width="1.66585" stroke-miterlimit="8" fill="none"/><text font-family="DengXian,DengXian_MSFontService,sans-serif" font-weight="400" font-size="15" transform="matrix(1 0 0 1.00159 441.759 166)">页号P</text><rect x="502" y="147.234" width="137" height="26.0415" stroke="#042433" stroke-width="1.66585" stroke-miterlimit="8" fill="none"/><text font-family="DengXian,DengXian_MSFontService,sans-serif" font-weight="400" font-size="15" transform="matrix(1 0 0 1.00159 527.489 166)">页表偏移量W</text><text font-family="DengXian,DengXian_MSFontService,sans-serif" font-weight="400" font-size="15" transform="matrix(1 0 0 1.00159 488.987 128)">逻辑地址A</text><path d="M329 91.6458C329 84.178 335.268 78.1243 343 78.1243 350.732 78.1243 357 84.178 357 91.6458 357 99.1135 350.732 105.167 343 105.167 335.268 105.167 329 99.1135 329 91.6458Z" stroke="#042433" stroke-width="1.66585" stroke-miterlimit="8" fill="none" fill-rule="evenodd"/><text font-family="Aptos,Aptos_MSFontService,sans-serif" font-weight="400" font-size="15" transform="matrix(1 0 0 1.00159 339.48 97)">&gt;</text><path d="M0.00179648-0.832923 63.5815-0.695792 63.5779 0.970054-0.00179648 0.832923ZM58.6992-3.91142 65.1513 0.140521 58.6817 4.1646C58.2911 4.40756 57.7775 4.28787 57.5345 3.89725 57.2916 3.50664 57.4113 2.99302 57.8019 2.75006L63.1398-0.570138 63.1367 0.842497 57.8132-2.50069C57.4236-2.74534 57.3062-3.25947 57.5508-3.64903 57.7955-4.03859 58.3096-4.15607 58.6992-3.91142Z" transform="matrix(1 0 0 -1.00159 264 92.2874)"/><path d="M0.000364705-0.832925 319.813-0.692892 319.812 0.972958-0.000364705 0.832925ZM314.924-3.90013 321.383 0.140722 314.92 4.17591C314.53 4.41955 314.016 4.30073 313.773 3.91054 313.529 3.52034 313.648 3.00652 314.038 2.76289L319.37-0.56648 319.37 0.846158 314.04-2.48788C313.65-2.73185 313.532-3.24578 313.776-3.63576 314.02-4.02574 314.534-4.1441 314.924-3.90013Z" transform="matrix(-1 0 0 1.00159 419.377 160.255)"/><path d="M69.1626 160.756 69.465 157.858 70.3331 155.157 71.7051 152.715 73.5195 150.591 75.716 148.841 78.2352 147.521 81.0173 146.686 84 146.396 86.9827 146.686 89.7649 147.521 92.2841 148.841 94.4805 150.591 96.2949 152.715 97.6669 155.157 98.535 157.858 98.8375 160.756 98.535 163.654 97.6669 166.355 96.2949 168.796 94.4805 170.92 92.2841 172.67 89.7649 173.991 86.9827 174.825 84 175.115 81.0173 174.825 78.2352 173.991 75.716 172.67 73.5195 170.92 71.7051 168.796 70.3331 166.355 69.465 163.654ZM71.1129 163.394 71.0773 163.225 71.8931 165.763 71.826 165.61 73.1168 167.906 73.0239 167.773 74.7334 169.774 74.6191 169.664 76.6911 171.315 76.5587 171.229 78.9368 172.475 78.7894 172.415 81.4174 173.203 81.2591 173.172 84.0806 173.447 83.9194 173.447 86.7409 173.172 86.5827 173.203 89.2106 172.415 89.0632 172.475 91.4413 171.229 91.309 171.315 93.381 169.664 93.2667 169.774 94.9762 167.773 94.8832 167.906 96.174 165.61 96.107 165.763 96.9228 163.225 96.8872 163.394 97.1716 160.669 97.1716 160.842 96.8872 158.117 96.9228 158.286 96.107 155.748 96.174 155.902 94.8832 153.605 94.9762 153.738 93.2667 151.737 93.381 151.847 91.309 150.196 91.4413 150.283 89.0632 149.036 89.2106 149.096 86.5827 148.308 86.7409 148.339 83.9194 148.065 84.0806 148.065 81.2591 148.339 81.4174 148.308 78.7894 149.096 78.9368 149.036 76.5587 150.283 76.6911 150.196 74.6191 151.847 74.7334 151.737 73.0239 153.738 73.1168 153.605 71.826 155.902 71.8931 155.748 71.0773 158.286 71.1129 158.117 70.8284 160.842 70.8284 160.669Z"/><text font-family="Aptos,Aptos_MSFontService,sans-serif" font-weight="400" font-size="15" transform="matrix(1 0 0 1.00159 80.0381 166)">+</text><path d="M84.8329 105.167 84.833 145.408 83.1672 145.408 83.1671 105.167ZM88.0381 140.511 84.0001 146.982 79.962 140.511C79.7182 140.12 79.8368 139.605 80.2269 139.361 80.617 139.117 81.1309 139.236 81.3747 139.626L84.7064 144.966 83.2938 144.966 86.6254 139.626C86.8692 139.236 87.3831 139.117 87.7732 139.361 88.1633 139.605 88.2819 140.12 88.0381 140.511Z"/><path d="M0.832925-1.58986e-06 0.833027 53.4095-0.832823 53.4095-0.832925 1.58986e-06ZM4.03811 48.5202 0.000104929 54.981-4.03793 48.5202C-4.28173 48.1301-4.16315 47.6162-3.77306 47.3724-3.38297 47.1286-2.8691 47.2472-2.62529 47.6373L0.70642 52.968-0.706218 52.968 2.62547 47.6373C2.86928 47.2472 3.38315 47.1286 3.77324 47.3724 4.16333 47.6162 4.28192 48.1301 4.03811 48.5202Z" transform="matrix(1 0 0 -1.00159 343 160.23)"/><path d="M0.832925-2.28257e-06 0.833026 36.7258-0.832824 36.7259-0.832925 2.28257e-06ZM4.03811 31.8365 0.000105063 38.2973-4.03793 31.8365C-4.28174 31.4464-4.16315 30.9326-3.77307 30.6887-3.38298 30.4449-2.8691 30.5635-2.6253 30.9536L0.706418 36.2843-0.70622 36.2843 2.62547 30.9536C2.86927 30.5635 3.38314 30.4449 3.77323 30.6887 4.16332 30.9325 4.28191 31.4464 4.03811 31.8365Z" transform="matrix(1 0 0 -1.00159 344 78.4164)"/><path d="M84 174.277 84.0001 371.846" stroke="#000000" stroke-width="1.66585" stroke-miterlimit="8" fill="none" fill-rule="evenodd"/><path d="M84 370.757 175.825 370.757 175.825 372.425 84 372.425ZM170.936 367.547 177.397 371.591 170.936 375.636C170.546 375.88 170.032 375.761 169.788 375.37 169.545 374.98 169.663 374.465 170.053 374.221L175.384 370.884 175.384 372.299 170.053 368.962C169.663 368.717 169.545 368.203 169.788 367.812 170.032 367.421 170.546 367.303 170.936 367.547Z"/><rect x="237" y="304.484" width="74" height="26.0415" stroke="#042433" stroke-width="1.66585" stroke-miterlimit="8" fill="none"/><text font-family="Aptos,Aptos_MSFontService,sans-serif" font-weight="400" font-size="15" transform="matrix(1 0 0 1.00159 262.011 323)">……</text><rect x="237" y="330.526" width="74" height="27.043" stroke="#042433" stroke-width="1.66585" stroke-miterlimit="8" fill="none"/><text font-family="Aptos,Aptos_MSFontService,sans-serif" font-weight="400" font-size="15" transform="matrix(1 0 0 1.00159 262.011 350)">……</text><rect x="237" y="357.569" width="74" height="26.0414" stroke="#042433" stroke-width="1.66585" stroke-miterlimit="8" fill="none"/><text font-family="Aptos,Aptos_MSFontService,sans-serif" font-weight="400" font-size="15" transform="matrix(1 0 0 1.00159 269.924 376)">b</text><rect x="237" y="383.61" width="74" height="26.0415" stroke="#042433" stroke-width="1.66585" stroke-miterlimit="8" fill="none"/><text font-family="Aptos,Aptos_MSFontService,sans-serif" font-weight="400" font-size="15" transform="matrix(1 0 0 1.00159 262.011 403)">……</text><text font-family="Aptos,Aptos_MSFontService,sans-serif" font-weight="400" font-size="15" transform="matrix(1 0 0 1.00159 187.512 323)">……</text><text font-family="Aptos,Aptos_MSFontService,sans-serif" font-weight="400" font-size="15" transform="matrix(1 0 0 1.00159 187.512 350)">……</text><text font-family="Aptos,Aptos_MSFontService,sans-serif" font-weight="400" font-size="15" transform="matrix(1 0 0 1.00159 195.259 376)">P</text><text font-family="Aptos,Aptos_MSFontService,sans-serif" font-weight="400" font-size="15" transform="matrix(1 0 0 1.00159 187.512 403)">……</text><text font-family="DengXian,DengXian_MSFontService,sans-serif" font-weight="400" font-size="15" transform="matrix(1 0 0 1.00159 184.781 286)">页号</text><text font-family="DengXian,DengXian_MSFontService,sans-serif" font-weight="400" font-size="15" transform="matrix(1 0 0 1.00159 241.087 286)">块号</text><text font-family="DengXian,DengXian_MSFontService,sans-serif" font-weight="400" font-size="15" transform="matrix(1 0 0 1.00159 213.209 438)">慢表</text><path d="M5.19835e-07-0.832925 166.571-0.832821 166.571 0.833029-5.19835e-07 0.832925ZM161.682-4.03792 168.142 0.000104676 161.682 4.03812C161.292 4.28193 160.778 4.16334 160.534 3.77325 160.29 3.38316 160.409 2.86929 160.799 2.62548L166.129-0.706215 166.129 0.706423 160.799-2.62528C160.409-2.86909 160.29-3.38296 160.534-3.77305 160.778-4.16314 161.292-4.28172 161.682-4.03792Z" transform="matrix(1 0 0 -1.00159 311 370.59)"/><rect x="533" y="357.569" width="75" height="26.0414" stroke="#042433" stroke-width="1.66585" stroke-miterlimit="8" fill="none"/><text font-family="Aptos,Aptos_MSFontService,sans-serif" font-weight="400" font-size="15" transform="matrix(1 0 0 1.00159 564.138 376)">W</text><path d="M0.832925-9.54342e-07 0.833133 181.604-0.832717 181.604-0.832925 9.54342e-07ZM4.03822 176.715 0.000209347 183.176-4.03782 176.715C-4.28162 176.325-4.16304 175.811-3.77295 175.567-3.38286 175.323-2.86899 175.442-2.62518 175.832L0.706527 181.162-0.706111 181.162 2.62558 175.832C2.86939 175.442 3.38326 175.323 3.77335 175.567 4.16344 175.811 4.28203 176.325 4.03822 176.715Z" transform="matrix(-1 0 0 1.00159 571 173.276)"/><rect x="479" y="357.569" width="54" height="26.0414" stroke="#042433" stroke-width="1.66585" stroke-miterlimit="8" fill="none"/><text font-family="Aptos,Aptos_MSFontService,sans-serif" font-weight="400" font-size="15" transform="matrix(1 0 0 1.00159 502.349 376)">b</text><rect x="404" y="239.381" width="75.0001" height="26.0414" stroke="#042433" stroke-width="1.66585" stroke-miterlimit="8" fill="none"/><text font-family="Aptos,Aptos_MSFontService,sans-serif" font-weight="400" font-size="15" transform="matrix(1 0 0 1.00159 429.634 258)">……</text><rect x="404" y="265.422" width="75.0001" height="27.043" stroke="#042433" stroke-width="1.66585" stroke-miterlimit="8" fill="none"/><text font-family="Aptos,Aptos_MSFontService,sans-serif" font-weight="400" font-size="15" transform="matrix(1 0 0 1.00159 437.547 284)">b</text><rect x="404" y="292.465" width="75.0001" height="26.0415" stroke="#042433" stroke-width="1.66585" stroke-miterlimit="8" fill="none"/><text font-family="Aptos,Aptos_MSFontService,sans-serif" font-weight="400" font-size="15" transform="matrix(1 0 0 1.00159 429.634 311)">……</text><text font-family="Aptos,Aptos_MSFontService,sans-serif" font-weight="400" font-size="15" transform="matrix(1 0 0 1.00159 355.135 258)">……</text><text font-family="Aptos,Aptos_MSFontService,sans-serif" font-weight="400" font-size="15" transform="matrix(1 0 0 1.00159 362.881 284)">P</text><text font-family="Aptos,Aptos_MSFontService,sans-serif" font-weight="400" font-size="15" transform="matrix(1 0 0 1.00159 355.135 311)">……</text><text font-family="DengXian,DengXian_MSFontService,sans-serif" font-weight="400" font-size="15" transform="matrix(1 0 0 1.00159 352.404 221)">页号</text><text font-family="DengXian,DengXian_MSFontService,sans-serif" font-weight="400" font-size="15" transform="matrix(1 0 0 1.00159 408.71 221)">块号</text><text font-family="DengXian,DengXian_MSFontService,sans-serif" font-weight="400" font-size="15" transform="matrix(1 0 0 1.00159 392.566 340)">快表</text><path d="M461 173.276 461 192.38" stroke="#000000" stroke-width="1.66585" stroke-miterlimit="8" fill="none" fill-rule="evenodd"/><path d="M330 193.307 460.787 193.308" stroke="#000000" stroke-width="1.66585" stroke-miterlimit="8" fill="none" fill-rule="evenodd"/><path d="M330 192.306 330 278.746" stroke="#000000" stroke-width="1.66585" stroke-miterlimit="8" fill="none" fill-rule="evenodd"/><path d="M0.00751085-0.832891 29.2899-0.568828 29.2749 1.09695-0.00751085 0.832891ZM24.4298-3.81788 30.854 0.278235 24.357 4.25783C23.9647 4.49811 23.4519 4.37489 23.2116 3.98262 22.9714 3.59035 23.0946 3.07757 23.4868 2.83729L28.8474-0.446208 28.8347 0.966373 23.5342-2.41326C23.1463-2.66057 23.0324-3.1755 23.2797-3.56337 23.527-3.95125 24.0419-4.06519 24.4298-3.81788Z" transform="matrix(1 0 0 -1.00159 330 278.722)"/><path d="M479 280.446 506.553 280.446" stroke="#000000" stroke-width="1.66585" stroke-miterlimit="8" fill="none" fill-rule="evenodd"/><path d="M0.832925-0.000238656 0.854828 76.4414-0.811022 76.4419-0.832925 0.000238656ZM4.05852 71.551 0.0223533 78.013-4.01752 71.5533C-4.26144 71.1633-4.143 70.6494-3.75298 70.4055-3.36296 70.1616-2.84905 70.28-2.60513 70.67L0.728095 75.9998-0.684543 76.0002 2.64563 70.6685C2.88932 70.2783 3.40316 70.1596 3.79332 70.4033 4.18348 70.647 4.30222 71.1608 4.05852 71.551Z" transform="matrix(-1 0 0 1.00159 506.022 279.445)"/></g></svg>

12. 增加快表后，地址变换过程为：

    ```mermaid
    graph LR
    	A(逻辑地址)-->B(页号)-->C{存在于快表}-->|是|D(页框号)-->G(物理地址)
    	C-->|否|E(访问慢表)-->D
    	A-->F(页内偏移量)-->G
    ```

13. 分页管理方式两个问题

    - 页表占用连续内存空间：对于页表所需的内存空间，采用离散分配方式，用一张索引表来记录各个页表的存放位置，该索引表称为外层页表/页目录
    - 页表占用内存过多：只将当前需要的部分页表项调入内存，其余的页表项仍驻留磁盘，需要时再调入

14. 为了方便实现地址变换，需要在系统中增设一个外层页表寄存器/页目录基址寄存器，用于存放页目录始址。将逻辑地址中的页目录号作为页目录的索引，从中找到对应页表的始址，再用二级页号作为页表分页的索引，从中找到对应的页表项；将页表项中的物理块号和页内偏移拼接，即为物理地址，再用该地址访问内存单元

### 基本分段存储管理

1. 分段系统将用户进程的逻辑地址空间划分为大小不等的段，段内要求连续，段间不要求连续

2. 分段存储管理的逻辑地址由段号S与段内偏移量W两部分组成

3. 在页式系统中，逻辑地址的页号和页内偏移量对用户是透明的，但在分段系统中，段号和段内偏移量必须由用户显式提供

4. 每个进程都有一张逻辑空间与内存空间映射的段表，进程的每个段对应一个段表项，段表项记录了该段在内存中的始址和段的长度

5. 为了实现进程从逻辑地址到物理地址的变换功能，在系统中设置了一个段表寄存器，用于存放段表始址F和段表长度M
   
   ![flower](https://telegraph-image-6b4.pages.dev/file/084bfeecb3f5fae0c1bbd.png)
   
6. 分页和分段的对比

   - 相同点
     - 都是非连续分配方式
     - 都要通过地址映射机构实现地址变换
   - 不同点
     - 页是信息的物理单位，分页的主要目的是提高内存利用率，分页完全是系统的行为，对用户不可见。段是信息的逻辑行为，分段的主要目的是更好地满足用户需求，用户按照逻辑关系将程序划分为若干段，分段对用户可见
     - 页的大小是固定的，由系统决定；段的长度不固定，由程序决定
     - 分页管理的地址空间是一维的；分段管理的地址空间是二维的

7. 分段系统中信息的共享：只要在每个进程的段表中设置一个段表项，指向被共享的同一物理段

8. 分段系统的保护方法：

   - 存取保护控制
   - 地址越界保护

### 段页式存储管理

1. 在段页式系统中，进程的地址空间首先被分为若干逻辑段，每段都有自己的段号，然后将每段分成若干大小固定的页。

2. 对内存空间的管理仍然和分页存储管理一样，将其分成若干和页面大小相同的存储块，对内存的分配以存储块为单位

3. 在段页式系统中，进程的逻辑地址分为三部分：段号S、页号P和页内偏移量W

4. 为了实现地址变换，系统为每个进程建立一张段表，每个段对应一个段表项，每个段表项至少包含段号、页表长度和页表始址；每个段有一张页表，每个页表项至少包含页号和块号。系统中还应有一个段表寄存器，指出进程的段表始址和段表长度

5. 在进行地址变换时，首先通过段表查到页表始址，然后通过页表找到物理块号，最后形成物理地址
   
   ![flower](https://telegraph-image-6b4.pages.dev/file/39467338a55ec75f9e7bc.png)

## 虚拟内存管理

### 虚拟内存的基本概念

1. 传统存储管理方式的特征
   - 一次性：作业必须一次性装入内存才能运行。这会导致两个问题：当作业很大无法装入内存时，作业无法运行；当大量作业要求运行时，由于内存不足，只有少数作业先运行，导致并发度下降
   - 驻留性：作业被装入内存后，就一直驻留在内存中，直到程序运行结束。运行中进程因等待I/O而被阻塞，可能处于长期等待状态
2. 局部性原理
   - 时间局部性原理：引用过一次的内存位置很可能在不远的将来再被多次引用
   - 空间局部性原理：如果一个内存位置被引用了一次，那么程序很可能在不远的将来引用其附近的一个内存位置
3. 在执行程序过程中，当访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序，这个过程就是请求**调页/调段**。当内存空间不够时，由操作系统负责将内存中暂时用不到的信息换出到外存，从而腾出空间存放将要调入内存的信息，这个过程就是**页面置换/段置换**
4. 虚拟存储器的主要特征
   - 多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存；当运行到尚未调入的那部分程序或数据时，再将它们调入
   - 对换性：在作业运行时无需常驻内存，而是允许在作业运行过程中，将那些暂不使用的程序和数据从内存调至外存的对换区，待以后需要时再将它们从外存调至内存
   - 虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量远大于实际容量
5. 虚拟内存的实现有以下三种方式：
   - 请求分页存储管理
   - 请求分段存储管理
   - 请求段页式存储管理
6. 不管哪种方式，都需要一定的硬件支持：
   - 一定容量的内存和外存
   - 页表机制/段表机制作为主要的数据结构
   - 中断机构，当用户程序要访问的尚未调入内存的部分时，产生中断
   - 地址变换机构，逻辑地址到物理地址的变换

### 请求分页管理方式

1. 请求分页系统中的页表项：页号+物理块号+状态位P+访问字段A+修改位M+外存地址

   - 状态位P：标记该页是否已调入内存
   - 访问字段A：记录本页在一段时间内被访问的次数，或记录本页最近已有多长时间未被访问
   - 修改位M：标记该页在调入内存后是否被修改过
   - 外存地址：记录该页在外存地存放地址，通常是物理块号

2. 缺页中断机构

   - 在请求分页系统中，每当要访问的页面不在内存时，便产生一个缺页中断，请求操作系统的缺页中断处理程序处理。此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列。若内存中有空闲页框，则为进程分配一个页框，将所缺页面从外存装入页框，并修改页表中的相应表项，若内存中没有空闲页框，则有页面置换算法选择一个页面淘汰，若该页在内存期间被修改过，则还要将其写回外存。未被修改过的页面不用写回
   - 缺页中断与中断的区别：
     - 在指令执行期间而非一条指令执行完后产生和处理中断，属于内部异常
     - 一条指令在执行期间，可能产生多次缺页中断

3. 地址变换机构
   
   ![flower](https://telegraph-image-6b4.pages.dev/file/6a8fd9b8b4cfd0ce57f6d.png)

### 页框分配

1. 给一个进程分配的页框集合就是这个进程的驻留集

   - 驻留集越小，驻留在内存中的进程就越多，可以提高多道程序的并发度，但分配给每个进程的页框太少，会导致缺页率较高，CPU需耗费大量时间来处理缺页
   - 驻留集越大，当分配给进程的页框超过某个数目时，再为进程增加页框对缺页率的改善是不明显的，反而只能是浪费内存空间，还会导致多道程序并发度的下降

2. 在请求分页系统中，可采取两种内存分配策略

   - 固定分配策略：为每个进程分配固定数目的物理块，在进程运行期间都不改变
   - 可变分配策略：先为每个进程分配一定数目的物理块，在进程运行期间可根据情况适当地增加或减少

   在进行置换时，也可采取两种策略

   - 局部置换：若进程在运行中发生缺页，则只能从分配给进程在内存中的页面中选出一页换出，然后再调入一页，以保证分配给该进程的内存空间不变
   - 全局置换：若进程在运行中发生缺页，则系统从空闲物理块队列中取出一块分配给该进程，并将所缺页调入

3. 页框分配策略：

   - **固定分配局部置换**：难以确定应为每个进程分配的物理块数目；太少会频繁出现缺页中断，太多会降低CPU和其他资源的利用率
   - **可变分配全局置换**：比固定分配局部置换更加灵活，可以动态增加进程的物理块，但它会盲目地给进程增加物理块，从而导致系统多道程序的并发能力下降
   - **可变分配局部置换**：若进程在运行中频繁地发生缺页中断，则系统再为该进程分配若干物理块，直到该进程的缺页率趋于适当程度；反之，若进程在运行中的缺页率特别低，则可适当减少分配给该进程的物理块，但不能引起缺页率明显增加

4. 采用固定分配策略时，将系统中的空闲物理块分配给各个进程，可采用下述几种方法：

   - 平均分配算法：将系统中所有可供分配的物理块平均分配给各个进程
   - 按比例分配算法：根据进程的大小按比例分配物理块
   - 优先权分配算法：为重要和紧迫的进程分配较多的物理块

5. 为确定系统将进程运行时所缺的页面调入内存的时机，可采用以下两种调页策略：

   - 预调页策略：根据局部性原理，一次调入若然个相邻的页面会比一次调入一页更高效。但若提前调入的页面中大多数都未被访问，则又是低效的。主要用于进程的首次调入
   - 请求调页策略：进程在运行中需要访问的页面不在内存，便提出请求，由系统将其所需页面调入内存。缺点是每次仅调入一页，增加了磁盘I/O开销

   预调页策略实际上在运行前调入；请求调页策略是运行期间调入

6. 请求分页系统的外存分为两部分

   - 文件区：存放文件，采用离散分配方式，I/O速度较慢
   - 对换区/交换区：用于存放兑换页面，采用连续分配方式，I/O速度较快

   发生缺页请求时，系统调入页面来源

   - 系统拥有足够的对换区空间：可以全部从对换区调入所需页面，以提高调页速度。在进程运行前，需将与该进程有关的文件从文件区复制到对换区
   - 系统缺少足够的对换区空间：凡是不会被修改的文件直接从文件区调入；当换出这些页面时，由于它们不会被修改而不必再换出。但对于那些可能被修改的部分，在将它们换出时必须放在对换区，以后需要时再从对换区调入
   - UNIX方式：与进程有关的文件都在文件区，因此未运行过的页面都应从文件区调入。曾经运行过但又被换出的页面应该从对换区调入。进程请求的共享页面若被其他进程调入主存，则不需要再从对换区调入

### 页面置换算法

1. 最佳置换算法
   - 选择淘汰的页面是以后永不使用或最长时间内不再被访问的页面
2. 先进先出页面置换算法
   - 选择淘汰的页面时最早进入内存的页面
   - 会产生分配的物理块增多，缺页次数不减反增的异常现象，称为Belady异常
3. 最近最久未使用置换算法
   - 选择淘汰的页面时最近最长时间未使用的页面
   - 性能较好，但需要寄存器和栈的硬件支持
4. 简单的CLOCK置换算法
   - 为每个页面设置一个访问位，当某页首次被装入或被访问时，其访问位被置为1.
   - 将内存中的页面链接成一个循环队列，并有一个替换指针与之相关联。当某一页被替换时，该指针被设置指向被替换页面的下一页。在选择淘汰一页时，只需检查页面的访问位：若为0，就选择该页换出；若为1，则将它置为0，暂不换出，依此检查下一个页面。当检查到队列中的最后一个页面时，若其访问为仍为1，则返回到队首去循环检查
5. 改进CLOCK置换算法
   - 在选择页面换出时，优先考虑既未使用过又未修改过的页面。由访问位A和修改位M可以组合成下面四种类型的页面：
     - (A, M) = (0, 0)：未被访问，未被修改
     - (A, M) = (0, 1)：未被访问，已被修改
     - (A, M) = (1, 0)：已被访问，未被修改
     - (A, M) = (1, 1)：已被访问，已被修改
   - 算法执行过程如下：
     - 从指针的当前位置开始，循环扫描队列，寻找(0, 0)的页面，将遇到的第一个页面作为淘汰页。扫描期间不修改访问位A
     - 若第一步失败，则进行第二轮扫描，寻找(0, 1)的页面。将遇到的第一个页面作为淘汰页。在扫描期间修改访问位A为0
     - 若第二步失败，则将将指针返回始址，寻找(0, 0)的页面，将遇到的第一个页面作为淘汰页。若查找失败，则寻找(0, 1)的页面，将遇到的第一个页面作为淘汰页

### 抖动和工作集

1. 抖动/颠簸：刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出内存
2. 系统发生抖动的根本原因：分配给每个进程的物理块太少，不能满足进程正常运行的物理要求，只是每个进程在运行时频繁地出现缺页，必须请求系统将所缺页面调入内存
3. 工作集是指在某段时间内，进程要访问的页面集合。一般来说，工作集W可由时间t和工作集窗口大小$\Delta$来确定
4. 工作集反映了进程在接下来的一段时间内很有可能会频繁访问的页面集合，因此驻留集大小不能小于工作集，否则进程在运行过程中会频繁缺页

### 内存映射文件

1. 内存映射文件是操作系统向应用程序提供的一个系统调用，在磁盘文件与进程的虚拟地址空间之间建立映射关系
2. 进程通过该系统调用，将一个文件映射到其虚拟地址空间的某个区域，之后就用访问内存的方式读写文件。将一个文件当作内存中的一个大字符数组来访问，而不通过文件I/O操作来访问
3. 映射进程的页面时，不会实际读入文件的内容，而只在访问页面时才被每次一页地读入。当进程退出或关闭文件映射时，所有被改动的页面才被写回磁盘文件
4. 共享内存是通过映射相同文件到通信进程的虚拟地址空间来实现的。当多个进程映射到同一文件时，各进程的虚拟地址空间都是相互独立地，但操作系统将对应的这些虚拟地址空间映射到相同的物理内存
5. 内存映射文件的好处：
   - 使程序员的编程更简单，已建立映射的文件只需要按访问内存的方式读写
   - 方便多个进程共享同一个磁盘文件

### 错题

1. 考虑页面置换算法，系统有m个物理块供调度，初始时全空，页面引用串长度为p，包含了n个不同的页号，无论用什么算法，缺页次数不会少于(  )

   A. m

   B. p

   C. n

   D. min(m, n)

2. 导致LRU算法实现起来耗费搞得原因是(  )

   A. 需要硬件的特殊支持

   B. 需要特殊的中断处理程序

   C. 需要在页表中表明特殊的页类型

   D. 需要对所有的页进行排序

3. 下列选项中，(  )不是页面换进换出效率的影响因素

   A. 页面置换算法

   B. 已修改页面写回磁盘的频率

   C. 磁盘数据读入内存的频率

   D. CPU与内存交换的速度

4. 已知系统为32位实地址，采取48位虚拟地址，页面大小为4KB，页表项大小为8B。假设系统使用纯页式存储，则要采用(  )级页表，页内偏移(  )位

   A. 3, 12

   B. 4, 14

   C. 4, 12

   D. 4, 14

5. 在请求分页存储管理系统中，为了提高TLB命中率，可行的方法是(  )

   I. 增大TLB容量

   II. 采用多级页表

   III. 增大页面大小

   IV. 减小页面大小

   A. I和III

   B. I和IV

   C. I、II和III

   D. II和III

6. 在缺页处理过程中，操作系统执行的操作可能是(  )

   I. 修改页表

   II. 磁盘I/O

   III. 分配页框

   A. 仅I、II

   B. 仅II

   C. 仅III

   D. I、II和III

7. 若用户进程访问内存时产生缺页，则下列选项中，操作系统可能执行的操作是(  )

   I. 处理越界错

   II. 置换页

   III. 分配内存

   A. 仅I、II

   B. 仅II、III

   C. 仅I、III

   D. I、II和III

8. 某请求分页存储系统的页大小为4KB，按字节编址。系统给进程P分配2个固定的页框，并采用改进型Clock置换算法，进程P页表的部分内容见下表

   | 页号 | 页框号 | 存在位<br />1：存在；0：不存在 | 访问位<br />1：访问；0：未访问 | 修改位<br />1：修改；0：未修改 |
   | :--: | :----: | :----------------------------: | :----------------------------: | :----------------------------: |
   |  …   |   …    |               …                |               …                |               …                |
   |  2   |  20H   |               0                |               0                |               0                |
   |  3   |  60H   |               1                |               1                |               0                |
   |  4   |  80H   |               1                |               1                |               1                |
   |  …   |   …    |               …                |               …                |               …                |

   若P访问虚拟地址位02A01H的存储单元，则经过地址变换后得到的物理地址是(  )

   A. 00A01H

   B. 20A01H

   C. 60A01H

   D. 80A01H
