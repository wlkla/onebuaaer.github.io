# 传输层

## 传输层提供的服务

### 传输层的功能

1. 传输层为运行在不同主机上的进程之间提供逻辑通信
2. 从网络层来说，通信双方是两台主机；从传输层来说，通信双方是主机中的进程
3. 复用和分用：
   - 复用：发送方不同的应用进程都可以使用同一传输层协议传送数据
   - 分用：接收方的传输层在剥去报文的首部后能够把这些数据正确交付到目的应用进程
4. 差错检测：传输层要对收到的报文进行差错检测。对于TCP协议，若接收方发现报文段出错，则要求发送方重发该报文段；对于UDP协议，若接收方发现数据报出错，则直接丢弃
5. 当传输层采用TCP协议时，逻辑通信信道相当于一条全双工的可靠信道；当传输层采用无连接的UDP协议时，逻辑通信信道相当于一条不可靠信道

### 传输层的寻址与端口

1. 端口能让应用层的各种进程将其数据通过端口向下交付给传输层，以及让传输层知道应当将其报文段中的数据向上通过端口交付给应用层的相应的进程

2. 端口号：

   - 长度：16bit

   - 端口号只标识本计算机应用层中的各进程

   - 端口号的分类：

     ```mermaid
     graph TB
     	A(端口号)
     	A-->B(服务器端使用的端口号)
     	A-->C(客户端使用的端口号)
     	B-->D(熟知端口号)-->E(0~1023，指派给TCP/IP最重要的一些应用程序)
     	B-->F(登记端口号)-->G(1024~49151，供没有熟知端口号的应用程序使用)
     	C-->H(49152~65535，仅在客户进程运行时动态选择)
     ```

3. 套接字 ::= {IP地址: 端口号}

   - 通过IP地址标识和区别网络中不同的主机，通过端口号标识和区别主机中不同的进程，端口号拼接到IP地址构成的套接字唯一标识一台主机上一个一个进程
   - 在网络通信中，主机A发给主机B的报文包含目的端口号和源端口号

### 无连接服务与面向连接服务

1. 面向连接的传输控制协议/TCP：传输层向上提供一条全双工的可靠逻辑信道
   - 通信双方在传送数据之前必须先建立连接，然后基于此连接进行可靠数据传输，传输结束后释放连接
   - 不提供广播或多播服务
   - 提供确认、流量控制、计时器、连接管理等功能，因此开销较大，适用于可靠性更重要的场合
2. 无连接的用户数据报协议/UDP：传输层向上提供一条不可靠的逻辑信道
   - 通信双方在传送数据之前不需要建立连接，接收方的传输层在收到UDP用户数据报后无须给发送方发回任何确认
   - 在IP层以上提供两种附加服务：多路复用和对数据的错误检查
   - 执行速度较快，实时性好，适用于小文件传送协议和实时传输协议

> 在网络层若采用虚电路方式，则无法提供无连接服务；若传输层采用TCP不影响网络层提供无连接服务

### 错题

1. 传输层的面向连接服务的特性是(  )

   A. 不保证可靠和顺序交付

   B. 不保证可靠但保证顺序交付

   C. 保证可靠但不保证顺序交付

   D. 保证可靠和顺序交付

2. 可靠传输协议中的“可靠”指的是(  )

   A. 使用面向连接的会话

   B. 使用尽力而为的传输

   C. 使用滑动窗口来维持可靠性

   D. 使用确认机制来确保传输的数据不丢失

3. 在TCP/IP参考模型中，若用户程序使用UDP进行数据传输，则(  )协议必须承担可靠性方面的全部工作

   A. 数据链路层

   B. 网际层

   C. 传输层

   D. 应用层

## UDP协议

### UDP数据报

1. UDP仅在IP层的数据报服务之上增加了两个最基本的功能：复用和分用、差错检测

2. UDP协议的特点：

   - UDP无须建立连接，因此UDP不会引入建立连接的时延
   - TCP需要在端系统中维护连接状态，UDP则不需要维护连接状态，因此能支持更多的客户机
   - UDP的首部开销小。TCP首部为20B，UDP首部为8B
   - UDP没有拥塞控制，因此网络中的拥塞不会影响源主机的发送速率
   - UDP支持一对一、一对多、多对一和多对多的交互通信

3. UDP是面向报文的。发送方UDP对应用层下来的报文，在添加首部后就向下交付给IP层，一次发送一个报文，既不合并，也不拆分；接收方UDP对IP层交上来的UDP报文，在去除首部后直接交付给应用进程。因此报文不可分割，是UDP数据报处理的最小单位。若报文太长，UDP把它交给IP层后，可能会导致分片；若报文太短，UDP把它交给IP层后，会使IP数据报的首部的相对长度太大，都会降低IP层的效率

4. UDP数据报的格式：

   ```mermaid
   graph LR
   	A(UDP数据报)
   	A-->B(首部字段)
   	A-->C(数据字段)
   	B-->D(源端口，2B)-->H(在需要对方回信时选用，不需要是可用全0)
   	B-->E(目的端口，2B)-->I(终点交付报文时用到)
   	B-->F(长度，2B)-->J(UDP数据报的长度)
   	B-->G(检验和，2B)-->K(检查数据报是否有误)
   ```

5. 若接收方UDP发现收到的报文中的目的端口号不正确，则丢弃该报文，并由ICMP发送“端口不可达”差错报文

### UDP检验

1. 在计算检验和时，要在UDP数据报之前增加12B的伪首部，得到一个临时的UDP数据报

   > IP数据报的检验和只检验数据报的首部，UDP数据报的检验和检验数据报的首部和数据部分

![flower](https://telegraph-image-6b4.pages.dev/file/37d374d5861fc8accfbf4.png)

2. 计算检验和的方法：

   1. 发送方首先把全0放入检验和字段并添加伪首部，然后把UDP数据报是为许多16位的字串接起来

   2. 若UDP数据报的数据部分不是偶数个字节，则要在尾部填入全0字节

   3. 按二进制反码计算出所有16位字的和，将结果的二进制反码写入检验和字段

   4. 接收方把收到的UDP数据报加上伪首部，同时可能要补全0字节

   5. 按二进制反码求出所有16位字的和。若结果为全1，则无差错

### 错题

1. 以下关于UDP检验和的说法中，错误的是(  )

   A. 计算检验和时需要按2字节对齐，若数据部分不足，则需用一个全0字节填充

   B. 若UDP检验和计算结果为0，则在检验和字段填充0

   C. UDP检验和字段的计算包括一个伪首部、UDP首部和携带的用户数据

   D. UDP检验和的计算方法是二进制反码运算求和再取反

2. 某应用层数据大小为200B，传输层使用UDP，网际层使用IP(采用最大首部长度)，使用以太网进行传输，则该应用层数据的传输效率为(  )

   A. 82.6%

   B. 77.5%

   C. 69.9%

   D. 67.1%

3. 一个UDP用户数据报的数据字段为8192B，要使用以太网来传送。假定IP数据报无选项。试问应当划分为几个IP数据报片？说明每个IP数据报片的数据字段长度和片段偏移字段的值

## TCP协议

### TCP协议的特点

1. TCP是在不可靠的IP层之上实现的可靠地数据传输协议，主要解决传输的可靠、有序、无丢失和不重复问题
2. TCP特点：
   - TCP是面向连接的传输层协议，TCP连接是一条逻辑链接
   - 每一条TCP连接只能有两个端点，是一对一的
   - TCP提供可靠交付的服务
   - TCP提供全双工通信，允许通信双方的应用进程在任何时候都能发送数据，为此TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双向通信的数据
     - 发送缓存存放的数据：发送应用程序传送给发送方TCP准备发送的数据；TCP已发送但尚未收到确认的数据
     - 接收缓存存放的数据：按序到达但尚未被接收应用程序读取的数据；不按序到达的数据
3. TCP与UDP的一些比较：
   - UDP报文的长度由发送应用进程决定
   - TCP报文的长度则根据接收方给定的窗口值和当前的网络拥塞程度决定
4. 若应用进程传送到TCP缓存的数据块太长，则TCP会进行拆分在传送；若数据块太短，则TCP会等到积累足够的字节后拼接发送

### TCP报文段

1. TCP传送的数据单元称为报文段。TCP报文段既可以用来运载数据，又可以用来建立连接、释放连接和应答

2. 一个TCP报文段分为首部和数据两部分，首部前20B是固定的，后面4N字节根据需要增加，长度为4B的整数倍

   ![flower](https://telegraph-image-6b4.pages.dev/file/d6174ba554fd1f78f94ee.png)

   - 源端口和目的端口：2B，标识发送方和接收方使用的端口
   - 序号：4B，TCP连接中传送的字节流中的每个字节都要按顺序变好，序号字段值是本报文段所发送的数据的第一个字节的序号
   - 确认号：4B，期望收到对方下一个报文段的第一个数据字节的序号。若确认号为N，则表明到序号N-1为止的所有数据均已正确收到
   - 数据偏移：4B，表示首部长度，指出TCP报文段的数据其实处距离TCP报文段起始处有多远
   - 保留：6bit，暂时置为0
   - 紧急位URG：当URG=1时，表明紧急指针字段有效，说明此报文段中有紧急数据，应尽快传送。紧急数据被插入到报文段数据的最前面
   - 确认位ACK：当ACK=1时确认号字段有效。TCP规定，在连接建立后所有传送的报文段都必须把ACK置为1
   - 推送位PSH：接受方TCP收到PSH=1的报文后，就尽快交付给接受应用程序，而不再等到整个缓存都满了再向上交付
   - 复位位RST：当RST=1时，表明TCP中出现严重差错，必须释放连接，然后重新建立传输连接；还可用于拒绝一个非法的报文段
   - 同步位SYN：当SYN=1时，表明这是一个连接请求或连接接收报文。当SYN=1，ACK=0时，表明这是一个请求连接报文。若对方同意建立连接，则发送SYN=1，ACK=1的响应报文
   - 终止位FIN：当FIN=1时，表明此报文段的发送方的数据已发送完毕，并请求释放传输连接
   - 窗口：2B，从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量
   - 检验和：2B，检验和字段检验的范围包括首部和数据两部分，方法类似UDP
   - 紧急指针：2B，紧急指针仅在URG=1时才有意义，指出本报文段中的紧急数据的字节数，窗口为零时也可以发送紧急数据
   - 选项：<40B
   - 填充：保持首部长度位4NB

### TCP连接管理

1. TCP连接的三个阶段：连接建立$\rightarrow$数据传送$\rightarrow$连接释放

2. 每条TCP连接都有两个端点，TCP连接的端口是套接字，每条TCP连接唯一地被通信的两个端点确定

3. 同一个IP地址可以有多个不同的TCP连接，而同一个端口号也可以出现在不同的TCP连接中

4. 主动发起连接的应用进程称为客户，被动等待连接建立的应用进程称为服务器

5. TCP连接的建立

   1. 客户机的TCP首先向服务器的TCP发送连接请求报文段，客户机进入SYN-SENT状态<font color='red'>(SYN=1,seq=x)</font>

      > SYN报文段不能携带数据，但会消耗掉一个序号

   2. 服务器的TCP收到连接请求报文段后，如果同意建立连接，则向客户机发挥确认，并为该TCP连接分配缓存和变量，服务器进入SYN-RCVD状态<font color='red'>(SYN=1,ACK=1,seq=y,ack=y+1)</font>

      > 确认报文段不能携带数据，但也要消耗掉一个序号

   3. 当客户机收到确认报文段后，还要向服务器给出确认，并为该TCP连接分配缓存和变量，客户机进入ESTABLISHED状态。当服务器收到来自客户机的确认后，也进入ESTABLISHED状态<font color='red'>(ACK=1,seq=x+1,ack=y+1)</font>

      > 该报文段可以携带数据，若不携带数据则不消耗序号

6. TCP连接的释放：参与TCP连接的两个进程中的任何一个都能终止该进程

   1. 客户机打算关闭连接时，向其TCP发送连接释放报文段，并停止发送数据，主动关闭TCP连接，客户机进入FIN-WAIT-1状态<font color='red'>(FIN=1,seq=u)</font>

      > FIN报文段无论是否携带数据，都要消耗掉一个序号

   2. 服务器收到连接释放报文段后即发出确认，服务器进入CLOSE-WAIT状态。此时服务器若发送数据，客户机仍要接受。客户机收到来自服务器的确认后，进入FIN-WAIT-2状态<font color='red'>(ACK=1,seq=v,ack=u+1)</font>

   3. 若服务器已经没有要向客户机发送的数据，就通知TCP释放连接，服务器进入LAST-ACK状态<font color='red'>(FIN=1,ACK=1,seq=w,ack=u+1)</font>

   4. 客户机收到连接释放报文段后，必须发出确认，之后进入TIME-WAIT状态。服务器收到确认报文后进入CLOSED状态，客户机进入TIME-WAIT状态，等待2MSL后才进入CLOSED状态<font color='red'>(ACK=1,seq=u+1,ack=w+1)</font>

      > MSL：最长报文段寿命
      >
      > 若服务器收到连接释放请求后不再发送数据，则从客户机发出FIN报文段时刻算起，客户机释放连接的最短时间为RTT+2MSL，服务器释放连接的最短时间为1.5RTT

### TCP可靠传输

1. TCP使用了检验、序号、确认和重传等机制来达到这一目的
2. 序号：
   - TCP首部的序号字段用来保证数据能有序提交给应用层，TCP把数据视为一个无结构但有序的字节流，序号建立在传送的字节流之上，而不建立在报文段上
3. 确认：
   - TCP首部的确认号是期望收到对方的下一个报文段的数据的第一个字节的序号
   - TCP使用累积确认，即TCP只确认数据流中至第一个丢失字节为止的字节
4. 重传：有两种事件会导致TCP对报文段进行重传
   - 超时
     - TCP每发送一个报文段，就对报文段设置一个超时计时器。计时器设置的重传时间到期还没收到确认时，就要重传这一报文段
     - TCP采用自适应算法，记录一个报文段的往返时间RTT。TCP维护了RTT的一个加权平均往返时间RTTS，会随着RTT样本是变化而改变。
   - 冗余ACK
     - 冗余ACK就是再次确认某个报文段的ACK，而发送方先前已经收到过该报文的确认
     - TCP规定每当比期望序号大的失序报文到达时，就发送一个冗余ACK，指明期待字节的序号

### TCP流量控制

1. TCP要求发送方维持一个接收窗口(rwnd)，接收方根据当前接受缓存的大小，动态调整接收窗口的大小，反映了接收方的容量
2. 接收方将窗口大小放在TCP报文首部中的窗口字段以通知对方。发送方的发送窗口不能超过接收方给出的接收窗口值，以限制发送方向网络注入报文的速率
3. TCP为每个连接设有一个持续计时器，只要发送方收到对方的零窗口通知，就启动计时器。若计时器超市，就发送一个零窗口探测报文段，而对方就在确认这个探测报文段时给出现在的窗口值。若窗口值仍为零，则发送方收到报文段后重置计时器
4. 传输层和数据链路层的流量控制的区别：
   - 传输层实现的是端到端，即两个进程之间的流量控制，窗口大小能动态变化
   - 数据链路层实现的是两个中间相邻结点之间的流量控制，窗口大小不能动态变化

### TCP拥塞控制

1. 拥塞控制是指防止过多的数据诸如网络，保证网络中的路由器或链路不过载
2. 拥塞控制与流量控制的区别：
   - 拥塞控制是让网络能够承受现有的网络负荷，是一个全局性的过程，涉及所有的主机、路由器，以及与降低网络传输性有关的所有因素
   - 流量控制指点对点的通信量的控制，要做的是抑制发送端发送数据的速率，以便使接收端来得及接收
3. TCP进行拥塞控制的算法：慢开始、拥塞避免、快重传、快恢复
4. TCP要求发送方维持一个拥塞窗口(cwnd)，其大小取决于网络的用色成都，并且动态地变化。发送方控制拥塞窗口的原则：只要未出现拥塞，拥塞窗口就增大；只要网络出现拥塞，拥塞窗口就减小
5. 发送窗口的上限=min(rwnd, cwnd)
6. 慢开始算法
   - 当发送方刚开始发送数据时，先发送少量数据探测，若没有发生拥塞，则将拥塞窗口扩大一倍
   - 为了防止cwnd增长过大引起网络拥塞，还要设置一个慢开始门限ssthresh。当慢开始一直把cwnd增大到ssthresh时，改用拥塞避免算法
   - 若2cwnd>ssthresh，则下一个RTT后的cwnd为ssthresh，而非2cwnd
7. 拥塞避免算法
   - 每经过一个往返时延RTT就把发送方的拥塞窗口cwnd+1，而非加倍，使cwnd按现行规律缓慢增大
   - 根据cwnd的大小执行不同的算法：
     - cwnd<ssthresh：慢开始算法
     - cwnd>ssthresh：拥塞避免算法
     - cwnd=ssthresh：慢开始算法/拥塞避免算法
   - 网络拥塞的处理：无论是在慢开始阶段还是拥塞避免阶段，只要发送方判断出网络出现拥塞，就要首先把ssthresh设置为cwnd/2，然后设置cwnd=1，执行慢开始算法
8. 快重传算法
   - 使发送方尽快进行重传，而不等计时器超时再重传。要求接收方不要等待自己发送数据时才进行稍待确认，而要立即发送确认，即使收到了失序的报文段也要立即发出对已收到报文段的重复确认
   - 发送方一旦受到连续3个冗余ACK，就要立即重传相应的报文段
9. 快恢复算法
   - 当发送方收到3个冗余ACK时，把ssthresh设置为cwnd/2，且把cwnd设置为cwnd/2，然后执行拥塞避免算法，使窗口线性增大
10. TCP连接建立和网络出现超时时，采用慢开始和拥塞避免算法(ssthresh=cwnd/2, cwnd=1)；当发送方收到3个连续冗余ACK帧时，采用快重传和快恢复算法(ssthresh=cwnd/2, cwnd=ssthresh)